// Code generated by ent, DO NOT EDIT.
// --------------------------------------------------------------
// SPDX-FileCopyrightText: Copyright Â© 2024 The Protobom Authors
// SPDX-FileType: SOURCE
// SPDX-License-Identifier: Apache-2.0
// --------------------------------------------------------------

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/protobom/storage/internal/backends/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/protobom/storage/internal/backends/ent/annotation"
	"github.com/protobom/storage/internal/backends/ent/document"
	"github.com/protobom/storage/internal/backends/ent/documenttype"
	"github.com/protobom/storage/internal/backends/ent/edgetype"
	"github.com/protobom/storage/internal/backends/ent/externalreference"
	"github.com/protobom/storage/internal/backends/ent/hashesentry"
	"github.com/protobom/storage/internal/backends/ent/identifiersentry"
	"github.com/protobom/storage/internal/backends/ent/metadata"
	"github.com/protobom/storage/internal/backends/ent/node"
	"github.com/protobom/storage/internal/backends/ent/nodelist"
	"github.com/protobom/storage/internal/backends/ent/person"
	"github.com/protobom/storage/internal/backends/ent/property"
	"github.com/protobom/storage/internal/backends/ent/purpose"
	"github.com/protobom/storage/internal/backends/ent/sourcedata"
	"github.com/protobom/storage/internal/backends/ent/tool"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Annotation is the client for interacting with the Annotation builders.
	Annotation *AnnotationClient
	// Document is the client for interacting with the Document builders.
	Document *DocumentClient
	// DocumentType is the client for interacting with the DocumentType builders.
	DocumentType *DocumentTypeClient
	// EdgeType is the client for interacting with the EdgeType builders.
	EdgeType *EdgeTypeClient
	// ExternalReference is the client for interacting with the ExternalReference builders.
	ExternalReference *ExternalReferenceClient
	// HashesEntry is the client for interacting with the HashesEntry builders.
	HashesEntry *HashesEntryClient
	// IdentifiersEntry is the client for interacting with the IdentifiersEntry builders.
	IdentifiersEntry *IdentifiersEntryClient
	// Metadata is the client for interacting with the Metadata builders.
	Metadata *MetadataClient
	// Node is the client for interacting with the Node builders.
	Node *NodeClient
	// NodeList is the client for interacting with the NodeList builders.
	NodeList *NodeListClient
	// Person is the client for interacting with the Person builders.
	Person *PersonClient
	// Property is the client for interacting with the Property builders.
	Property *PropertyClient
	// Purpose is the client for interacting with the Purpose builders.
	Purpose *PurposeClient
	// SourceData is the client for interacting with the SourceData builders.
	SourceData *SourceDataClient
	// Tool is the client for interacting with the Tool builders.
	Tool *ToolClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Annotation = NewAnnotationClient(c.config)
	c.Document = NewDocumentClient(c.config)
	c.DocumentType = NewDocumentTypeClient(c.config)
	c.EdgeType = NewEdgeTypeClient(c.config)
	c.ExternalReference = NewExternalReferenceClient(c.config)
	c.HashesEntry = NewHashesEntryClient(c.config)
	c.IdentifiersEntry = NewIdentifiersEntryClient(c.config)
	c.Metadata = NewMetadataClient(c.config)
	c.Node = NewNodeClient(c.config)
	c.NodeList = NewNodeListClient(c.config)
	c.Person = NewPersonClient(c.config)
	c.Property = NewPropertyClient(c.config)
	c.Purpose = NewPurposeClient(c.config)
	c.SourceData = NewSourceDataClient(c.config)
	c.Tool = NewToolClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Annotation:        NewAnnotationClient(cfg),
		Document:          NewDocumentClient(cfg),
		DocumentType:      NewDocumentTypeClient(cfg),
		EdgeType:          NewEdgeTypeClient(cfg),
		ExternalReference: NewExternalReferenceClient(cfg),
		HashesEntry:       NewHashesEntryClient(cfg),
		IdentifiersEntry:  NewIdentifiersEntryClient(cfg),
		Metadata:          NewMetadataClient(cfg),
		Node:              NewNodeClient(cfg),
		NodeList:          NewNodeListClient(cfg),
		Person:            NewPersonClient(cfg),
		Property:          NewPropertyClient(cfg),
		Purpose:           NewPurposeClient(cfg),
		SourceData:        NewSourceDataClient(cfg),
		Tool:              NewToolClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Annotation:        NewAnnotationClient(cfg),
		Document:          NewDocumentClient(cfg),
		DocumentType:      NewDocumentTypeClient(cfg),
		EdgeType:          NewEdgeTypeClient(cfg),
		ExternalReference: NewExternalReferenceClient(cfg),
		HashesEntry:       NewHashesEntryClient(cfg),
		IdentifiersEntry:  NewIdentifiersEntryClient(cfg),
		Metadata:          NewMetadataClient(cfg),
		Node:              NewNodeClient(cfg),
		NodeList:          NewNodeListClient(cfg),
		Person:            NewPersonClient(cfg),
		Property:          NewPropertyClient(cfg),
		Purpose:           NewPurposeClient(cfg),
		SourceData:        NewSourceDataClient(cfg),
		Tool:              NewToolClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Annotation.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Annotation, c.Document, c.DocumentType, c.EdgeType, c.ExternalReference,
		c.HashesEntry, c.IdentifiersEntry, c.Metadata, c.Node, c.NodeList, c.Person,
		c.Property, c.Purpose, c.SourceData, c.Tool,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Annotation, c.Document, c.DocumentType, c.EdgeType, c.ExternalReference,
		c.HashesEntry, c.IdentifiersEntry, c.Metadata, c.Node, c.NodeList, c.Person,
		c.Property, c.Purpose, c.SourceData, c.Tool,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AnnotationMutation:
		return c.Annotation.mutate(ctx, m)
	case *DocumentMutation:
		return c.Document.mutate(ctx, m)
	case *DocumentTypeMutation:
		return c.DocumentType.mutate(ctx, m)
	case *EdgeTypeMutation:
		return c.EdgeType.mutate(ctx, m)
	case *ExternalReferenceMutation:
		return c.ExternalReference.mutate(ctx, m)
	case *HashesEntryMutation:
		return c.HashesEntry.mutate(ctx, m)
	case *IdentifiersEntryMutation:
		return c.IdentifiersEntry.mutate(ctx, m)
	case *MetadataMutation:
		return c.Metadata.mutate(ctx, m)
	case *NodeMutation:
		return c.Node.mutate(ctx, m)
	case *NodeListMutation:
		return c.NodeList.mutate(ctx, m)
	case *PersonMutation:
		return c.Person.mutate(ctx, m)
	case *PropertyMutation:
		return c.Property.mutate(ctx, m)
	case *PurposeMutation:
		return c.Purpose.mutate(ctx, m)
	case *SourceDataMutation:
		return c.SourceData.mutate(ctx, m)
	case *ToolMutation:
		return c.Tool.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AnnotationClient is a client for the Annotation schema.
type AnnotationClient struct {
	config
}

// NewAnnotationClient returns a client for the Annotation from the given config.
func NewAnnotationClient(c config) *AnnotationClient {
	return &AnnotationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `annotation.Hooks(f(g(h())))`.
func (c *AnnotationClient) Use(hooks ...Hook) {
	c.hooks.Annotation = append(c.hooks.Annotation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `annotation.Intercept(f(g(h())))`.
func (c *AnnotationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Annotation = append(c.inters.Annotation, interceptors...)
}

// Create returns a builder for creating a Annotation entity.
func (c *AnnotationClient) Create() *AnnotationCreate {
	mutation := newAnnotationMutation(c.config, OpCreate)
	return &AnnotationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Annotation entities.
func (c *AnnotationClient) CreateBulk(builders ...*AnnotationCreate) *AnnotationCreateBulk {
	return &AnnotationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AnnotationClient) MapCreateBulk(slice any, setFunc func(*AnnotationCreate, int)) *AnnotationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AnnotationCreateBulk{err: fmt.Errorf("calling to AnnotationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AnnotationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AnnotationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Annotation.
func (c *AnnotationClient) Update() *AnnotationUpdate {
	mutation := newAnnotationMutation(c.config, OpUpdate)
	return &AnnotationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnnotationClient) UpdateOne(a *Annotation) *AnnotationUpdateOne {
	mutation := newAnnotationMutation(c.config, OpUpdateOne, withAnnotation(a))
	return &AnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnnotationClient) UpdateOneID(id int) *AnnotationUpdateOne {
	mutation := newAnnotationMutation(c.config, OpUpdateOne, withAnnotationID(id))
	return &AnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Annotation.
func (c *AnnotationClient) Delete() *AnnotationDelete {
	mutation := newAnnotationMutation(c.config, OpDelete)
	return &AnnotationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnnotationClient) DeleteOne(a *Annotation) *AnnotationDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnnotationClient) DeleteOneID(id int) *AnnotationDeleteOne {
	builder := c.Delete().Where(annotation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnnotationDeleteOne{builder}
}

// Query returns a query builder for Annotation.
func (c *AnnotationClient) Query() *AnnotationQuery {
	return &AnnotationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnnotation},
		inters: c.Interceptors(),
	}
}

// Get returns a Annotation entity by its id.
func (c *AnnotationClient) Get(ctx context.Context, id int) (*Annotation, error) {
	return c.Query().Where(annotation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnnotationClient) GetX(ctx context.Context, id int) *Annotation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a Annotation.
func (c *AnnotationClient) QueryDocument(a *Annotation) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(annotation.Table, annotation.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, annotation.DocumentTable, annotation.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNode queries the node edge of a Annotation.
func (c *AnnotationClient) QueryNode(a *Annotation) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(annotation.Table, annotation.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, annotation.NodeTable, annotation.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnnotationClient) Hooks() []Hook {
	return c.hooks.Annotation
}

// Interceptors returns the client interceptors.
func (c *AnnotationClient) Interceptors() []Interceptor {
	return c.inters.Annotation
}

func (c *AnnotationClient) mutate(ctx context.Context, m *AnnotationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnnotationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnnotationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnnotationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Annotation mutation op: %q", m.Op())
	}
}

// DocumentClient is a client for the Document schema.
type DocumentClient struct {
	config
}

// NewDocumentClient returns a client for the Document from the given config.
func NewDocumentClient(c config) *DocumentClient {
	return &DocumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `document.Hooks(f(g(h())))`.
func (c *DocumentClient) Use(hooks ...Hook) {
	c.hooks.Document = append(c.hooks.Document, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `document.Intercept(f(g(h())))`.
func (c *DocumentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Document = append(c.inters.Document, interceptors...)
}

// Create returns a builder for creating a Document entity.
func (c *DocumentClient) Create() *DocumentCreate {
	mutation := newDocumentMutation(c.config, OpCreate)
	return &DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Document entities.
func (c *DocumentClient) CreateBulk(builders ...*DocumentCreate) *DocumentCreateBulk {
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentClient) MapCreateBulk(slice any, setFunc func(*DocumentCreate, int)) *DocumentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentCreateBulk{err: fmt.Errorf("calling to DocumentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Document.
func (c *DocumentClient) Update() *DocumentUpdate {
	mutation := newDocumentMutation(c.config, OpUpdate)
	return &DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentClient) UpdateOne(d *Document) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocument(d))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentClient) UpdateOneID(id uuid.UUID) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocumentID(id))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Document.
func (c *DocumentClient) Delete() *DocumentDelete {
	mutation := newDocumentMutation(c.config, OpDelete)
	return &DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentClient) DeleteOne(d *Document) *DocumentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentClient) DeleteOneID(id uuid.UUID) *DocumentDeleteOne {
	builder := c.Delete().Where(document.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDeleteOne{builder}
}

// Query returns a query builder for Document.
func (c *DocumentClient) Query() *DocumentQuery {
	return &DocumentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocument},
		inters: c.Interceptors(),
	}
}

// Get returns a Document entity by its id.
func (c *DocumentClient) Get(ctx context.Context, id uuid.UUID) (*Document, error) {
	return c.Query().Where(document.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentClient) GetX(ctx context.Context, id uuid.UUID) *Document {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAnnotations queries the annotations edge of a Document.
func (c *DocumentClient) QueryAnnotations(d *Document) *AnnotationQuery {
	query := (&AnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(annotation.Table, annotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, document.AnnotationsTable, document.AnnotationsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a Document.
func (c *DocumentClient) QueryMetadata(d *Document) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, document.MetadataTable, document.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodeList queries the node_list edge of a Document.
func (c *DocumentClient) QueryNodeList(d *Document) *NodeListQuery {
	query := (&NodeListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(nodelist.Table, nodelist.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, document.NodeListTable, document.NodeListColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentClient) Hooks() []Hook {
	return c.hooks.Document
}

// Interceptors returns the client interceptors.
func (c *DocumentClient) Interceptors() []Interceptor {
	return c.inters.Document
}

func (c *DocumentClient) mutate(ctx context.Context, m *DocumentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Document mutation op: %q", m.Op())
	}
}

// DocumentTypeClient is a client for the DocumentType schema.
type DocumentTypeClient struct {
	config
}

// NewDocumentTypeClient returns a client for the DocumentType from the given config.
func NewDocumentTypeClient(c config) *DocumentTypeClient {
	return &DocumentTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `documenttype.Hooks(f(g(h())))`.
func (c *DocumentTypeClient) Use(hooks ...Hook) {
	c.hooks.DocumentType = append(c.hooks.DocumentType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `documenttype.Intercept(f(g(h())))`.
func (c *DocumentTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.DocumentType = append(c.inters.DocumentType, interceptors...)
}

// Create returns a builder for creating a DocumentType entity.
func (c *DocumentTypeClient) Create() *DocumentTypeCreate {
	mutation := newDocumentTypeMutation(c.config, OpCreate)
	return &DocumentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DocumentType entities.
func (c *DocumentTypeClient) CreateBulk(builders ...*DocumentTypeCreate) *DocumentTypeCreateBulk {
	return &DocumentTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentTypeClient) MapCreateBulk(slice any, setFunc func(*DocumentTypeCreate, int)) *DocumentTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentTypeCreateBulk{err: fmt.Errorf("calling to DocumentTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DocumentType.
func (c *DocumentTypeClient) Update() *DocumentTypeUpdate {
	mutation := newDocumentTypeMutation(c.config, OpUpdate)
	return &DocumentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentTypeClient) UpdateOne(dt *DocumentType) *DocumentTypeUpdateOne {
	mutation := newDocumentTypeMutation(c.config, OpUpdateOne, withDocumentType(dt))
	return &DocumentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentTypeClient) UpdateOneID(id uuid.UUID) *DocumentTypeUpdateOne {
	mutation := newDocumentTypeMutation(c.config, OpUpdateOne, withDocumentTypeID(id))
	return &DocumentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DocumentType.
func (c *DocumentTypeClient) Delete() *DocumentTypeDelete {
	mutation := newDocumentTypeMutation(c.config, OpDelete)
	return &DocumentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentTypeClient) DeleteOne(dt *DocumentType) *DocumentTypeDeleteOne {
	return c.DeleteOneID(dt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentTypeClient) DeleteOneID(id uuid.UUID) *DocumentTypeDeleteOne {
	builder := c.Delete().Where(documenttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentTypeDeleteOne{builder}
}

// Query returns a query builder for DocumentType.
func (c *DocumentTypeClient) Query() *DocumentTypeQuery {
	return &DocumentTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocumentType},
		inters: c.Interceptors(),
	}
}

// Get returns a DocumentType entity by its id.
func (c *DocumentTypeClient) Get(ctx context.Context, id uuid.UUID) (*DocumentType, error) {
	return c.Query().Where(documenttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentTypeClient) GetX(ctx context.Context, id uuid.UUID) *DocumentType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a DocumentType.
func (c *DocumentTypeClient) QueryDocument(dt *DocumentType) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documenttype.Table, documenttype.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, documenttype.DocumentTable, documenttype.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(dt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a DocumentType.
func (c *DocumentTypeClient) QueryMetadata(dt *DocumentType) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documenttype.Table, documenttype.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, documenttype.MetadataTable, documenttype.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(dt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentTypeClient) Hooks() []Hook {
	return c.hooks.DocumentType
}

// Interceptors returns the client interceptors.
func (c *DocumentTypeClient) Interceptors() []Interceptor {
	return c.inters.DocumentType
}

func (c *DocumentTypeClient) mutate(ctx context.Context, m *DocumentTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DocumentType mutation op: %q", m.Op())
	}
}

// EdgeTypeClient is a client for the EdgeType schema.
type EdgeTypeClient struct {
	config
}

// NewEdgeTypeClient returns a client for the EdgeType from the given config.
func NewEdgeTypeClient(c config) *EdgeTypeClient {
	return &EdgeTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `edgetype.Hooks(f(g(h())))`.
func (c *EdgeTypeClient) Use(hooks ...Hook) {
	c.hooks.EdgeType = append(c.hooks.EdgeType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `edgetype.Intercept(f(g(h())))`.
func (c *EdgeTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.EdgeType = append(c.inters.EdgeType, interceptors...)
}

// Create returns a builder for creating a EdgeType entity.
func (c *EdgeTypeClient) Create() *EdgeTypeCreate {
	mutation := newEdgeTypeMutation(c.config, OpCreate)
	return &EdgeTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EdgeType entities.
func (c *EdgeTypeClient) CreateBulk(builders ...*EdgeTypeCreate) *EdgeTypeCreateBulk {
	return &EdgeTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EdgeTypeClient) MapCreateBulk(slice any, setFunc func(*EdgeTypeCreate, int)) *EdgeTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EdgeTypeCreateBulk{err: fmt.Errorf("calling to EdgeTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EdgeTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EdgeTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EdgeType.
func (c *EdgeTypeClient) Update() *EdgeTypeUpdate {
	mutation := newEdgeTypeMutation(c.config, OpUpdate)
	return &EdgeTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EdgeTypeClient) UpdateOne(et *EdgeType) *EdgeTypeUpdateOne {
	mutation := newEdgeTypeMutation(c.config, OpUpdateOne, withEdgeType(et))
	return &EdgeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EdgeTypeClient) UpdateOneID(id uuid.UUID) *EdgeTypeUpdateOne {
	mutation := newEdgeTypeMutation(c.config, OpUpdateOne, withEdgeTypeID(id))
	return &EdgeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EdgeType.
func (c *EdgeTypeClient) Delete() *EdgeTypeDelete {
	mutation := newEdgeTypeMutation(c.config, OpDelete)
	return &EdgeTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EdgeTypeClient) DeleteOne(et *EdgeType) *EdgeTypeDeleteOne {
	return c.DeleteOneID(et.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EdgeTypeClient) DeleteOneID(id uuid.UUID) *EdgeTypeDeleteOne {
	builder := c.Delete().Where(edgetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EdgeTypeDeleteOne{builder}
}

// Query returns a query builder for EdgeType.
func (c *EdgeTypeClient) Query() *EdgeTypeQuery {
	return &EdgeTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEdgeType},
		inters: c.Interceptors(),
	}
}

// Get returns a EdgeType entity by its id.
func (c *EdgeTypeClient) Get(ctx context.Context, id uuid.UUID) (*EdgeType, error) {
	return c.Query().Where(edgetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EdgeTypeClient) GetX(ctx context.Context, id uuid.UUID) *EdgeType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a EdgeType.
func (c *EdgeTypeClient) QueryDocument(et *EdgeType) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := et.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(edgetype.Table, edgetype.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, edgetype.DocumentTable, edgetype.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(et.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFrom queries the from edge of a EdgeType.
func (c *EdgeTypeClient) QueryFrom(et *EdgeType) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := et.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(edgetype.Table, edgetype.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, edgetype.FromTable, edgetype.FromColumn),
		)
		fromV = sqlgraph.Neighbors(et.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTo queries the to edge of a EdgeType.
func (c *EdgeTypeClient) QueryTo(et *EdgeType) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := et.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(edgetype.Table, edgetype.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, edgetype.ToTable, edgetype.ToColumn),
		)
		fromV = sqlgraph.Neighbors(et.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodeLists queries the node_lists edge of a EdgeType.
func (c *EdgeTypeClient) QueryNodeLists(et *EdgeType) *NodeListQuery {
	query := (&NodeListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := et.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(edgetype.Table, edgetype.FieldID, id),
			sqlgraph.To(nodelist.Table, nodelist.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, edgetype.NodeListsTable, edgetype.NodeListsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(et.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EdgeTypeClient) Hooks() []Hook {
	return c.hooks.EdgeType
}

// Interceptors returns the client interceptors.
func (c *EdgeTypeClient) Interceptors() []Interceptor {
	return c.inters.EdgeType
}

func (c *EdgeTypeClient) mutate(ctx context.Context, m *EdgeTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EdgeTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EdgeTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EdgeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EdgeTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EdgeType mutation op: %q", m.Op())
	}
}

// ExternalReferenceClient is a client for the ExternalReference schema.
type ExternalReferenceClient struct {
	config
}

// NewExternalReferenceClient returns a client for the ExternalReference from the given config.
func NewExternalReferenceClient(c config) *ExternalReferenceClient {
	return &ExternalReferenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `externalreference.Hooks(f(g(h())))`.
func (c *ExternalReferenceClient) Use(hooks ...Hook) {
	c.hooks.ExternalReference = append(c.hooks.ExternalReference, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `externalreference.Intercept(f(g(h())))`.
func (c *ExternalReferenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExternalReference = append(c.inters.ExternalReference, interceptors...)
}

// Create returns a builder for creating a ExternalReference entity.
func (c *ExternalReferenceClient) Create() *ExternalReferenceCreate {
	mutation := newExternalReferenceMutation(c.config, OpCreate)
	return &ExternalReferenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExternalReference entities.
func (c *ExternalReferenceClient) CreateBulk(builders ...*ExternalReferenceCreate) *ExternalReferenceCreateBulk {
	return &ExternalReferenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExternalReferenceClient) MapCreateBulk(slice any, setFunc func(*ExternalReferenceCreate, int)) *ExternalReferenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExternalReferenceCreateBulk{err: fmt.Errorf("calling to ExternalReferenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExternalReferenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExternalReferenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExternalReference.
func (c *ExternalReferenceClient) Update() *ExternalReferenceUpdate {
	mutation := newExternalReferenceMutation(c.config, OpUpdate)
	return &ExternalReferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExternalReferenceClient) UpdateOne(er *ExternalReference) *ExternalReferenceUpdateOne {
	mutation := newExternalReferenceMutation(c.config, OpUpdateOne, withExternalReference(er))
	return &ExternalReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExternalReferenceClient) UpdateOneID(id uuid.UUID) *ExternalReferenceUpdateOne {
	mutation := newExternalReferenceMutation(c.config, OpUpdateOne, withExternalReferenceID(id))
	return &ExternalReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExternalReference.
func (c *ExternalReferenceClient) Delete() *ExternalReferenceDelete {
	mutation := newExternalReferenceMutation(c.config, OpDelete)
	return &ExternalReferenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExternalReferenceClient) DeleteOne(er *ExternalReference) *ExternalReferenceDeleteOne {
	return c.DeleteOneID(er.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExternalReferenceClient) DeleteOneID(id uuid.UUID) *ExternalReferenceDeleteOne {
	builder := c.Delete().Where(externalreference.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExternalReferenceDeleteOne{builder}
}

// Query returns a query builder for ExternalReference.
func (c *ExternalReferenceClient) Query() *ExternalReferenceQuery {
	return &ExternalReferenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExternalReference},
		inters: c.Interceptors(),
	}
}

// Get returns a ExternalReference entity by its id.
func (c *ExternalReferenceClient) Get(ctx context.Context, id uuid.UUID) (*ExternalReference, error) {
	return c.Query().Where(externalreference.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExternalReferenceClient) GetX(ctx context.Context, id uuid.UUID) *ExternalReference {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a ExternalReference.
func (c *ExternalReferenceClient) QueryDocument(er *ExternalReference) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := er.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(externalreference.Table, externalreference.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, externalreference.DocumentTable, externalreference.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(er.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHashes queries the hashes edge of a ExternalReference.
func (c *ExternalReferenceClient) QueryHashes(er *ExternalReference) *HashesEntryQuery {
	query := (&HashesEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := er.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(externalreference.Table, externalreference.FieldID, id),
			sqlgraph.To(hashesentry.Table, hashesentry.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, externalreference.HashesTable, externalreference.HashesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(er.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a ExternalReference.
func (c *ExternalReferenceClient) QueryNodes(er *ExternalReference) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := er.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(externalreference.Table, externalreference.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, externalreference.NodesTable, externalreference.NodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(er.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExternalReferenceClient) Hooks() []Hook {
	return c.hooks.ExternalReference
}

// Interceptors returns the client interceptors.
func (c *ExternalReferenceClient) Interceptors() []Interceptor {
	return c.inters.ExternalReference
}

func (c *ExternalReferenceClient) mutate(ctx context.Context, m *ExternalReferenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExternalReferenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExternalReferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExternalReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExternalReferenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExternalReference mutation op: %q", m.Op())
	}
}

// HashesEntryClient is a client for the HashesEntry schema.
type HashesEntryClient struct {
	config
}

// NewHashesEntryClient returns a client for the HashesEntry from the given config.
func NewHashesEntryClient(c config) *HashesEntryClient {
	return &HashesEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hashesentry.Hooks(f(g(h())))`.
func (c *HashesEntryClient) Use(hooks ...Hook) {
	c.hooks.HashesEntry = append(c.hooks.HashesEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hashesentry.Intercept(f(g(h())))`.
func (c *HashesEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.HashesEntry = append(c.inters.HashesEntry, interceptors...)
}

// Create returns a builder for creating a HashesEntry entity.
func (c *HashesEntryClient) Create() *HashesEntryCreate {
	mutation := newHashesEntryMutation(c.config, OpCreate)
	return &HashesEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HashesEntry entities.
func (c *HashesEntryClient) CreateBulk(builders ...*HashesEntryCreate) *HashesEntryCreateBulk {
	return &HashesEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HashesEntryClient) MapCreateBulk(slice any, setFunc func(*HashesEntryCreate, int)) *HashesEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HashesEntryCreateBulk{err: fmt.Errorf("calling to HashesEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HashesEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HashesEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HashesEntry.
func (c *HashesEntryClient) Update() *HashesEntryUpdate {
	mutation := newHashesEntryMutation(c.config, OpUpdate)
	return &HashesEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HashesEntryClient) UpdateOne(he *HashesEntry) *HashesEntryUpdateOne {
	mutation := newHashesEntryMutation(c.config, OpUpdateOne, withHashesEntry(he))
	return &HashesEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HashesEntryClient) UpdateOneID(id uuid.UUID) *HashesEntryUpdateOne {
	mutation := newHashesEntryMutation(c.config, OpUpdateOne, withHashesEntryID(id))
	return &HashesEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HashesEntry.
func (c *HashesEntryClient) Delete() *HashesEntryDelete {
	mutation := newHashesEntryMutation(c.config, OpDelete)
	return &HashesEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HashesEntryClient) DeleteOne(he *HashesEntry) *HashesEntryDeleteOne {
	return c.DeleteOneID(he.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HashesEntryClient) DeleteOneID(id uuid.UUID) *HashesEntryDeleteOne {
	builder := c.Delete().Where(hashesentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HashesEntryDeleteOne{builder}
}

// Query returns a query builder for HashesEntry.
func (c *HashesEntryClient) Query() *HashesEntryQuery {
	return &HashesEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHashesEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a HashesEntry entity by its id.
func (c *HashesEntryClient) Get(ctx context.Context, id uuid.UUID) (*HashesEntry, error) {
	return c.Query().Where(hashesentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HashesEntryClient) GetX(ctx context.Context, id uuid.UUID) *HashesEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a HashesEntry.
func (c *HashesEntryClient) QueryDocument(he *HashesEntry) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := he.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hashesentry.Table, hashesentry.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hashesentry.DocumentTable, hashesentry.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(he.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExternalReferences queries the external_references edge of a HashesEntry.
func (c *HashesEntryClient) QueryExternalReferences(he *HashesEntry) *ExternalReferenceQuery {
	query := (&ExternalReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := he.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hashesentry.Table, hashesentry.FieldID, id),
			sqlgraph.To(externalreference.Table, externalreference.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, hashesentry.ExternalReferencesTable, hashesentry.ExternalReferencesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(he.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a HashesEntry.
func (c *HashesEntryClient) QueryNodes(he *HashesEntry) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := he.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hashesentry.Table, hashesentry.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, hashesentry.NodesTable, hashesentry.NodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(he.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HashesEntryClient) Hooks() []Hook {
	return c.hooks.HashesEntry
}

// Interceptors returns the client interceptors.
func (c *HashesEntryClient) Interceptors() []Interceptor {
	return c.inters.HashesEntry
}

func (c *HashesEntryClient) mutate(ctx context.Context, m *HashesEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HashesEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HashesEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HashesEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HashesEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HashesEntry mutation op: %q", m.Op())
	}
}

// IdentifiersEntryClient is a client for the IdentifiersEntry schema.
type IdentifiersEntryClient struct {
	config
}

// NewIdentifiersEntryClient returns a client for the IdentifiersEntry from the given config.
func NewIdentifiersEntryClient(c config) *IdentifiersEntryClient {
	return &IdentifiersEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `identifiersentry.Hooks(f(g(h())))`.
func (c *IdentifiersEntryClient) Use(hooks ...Hook) {
	c.hooks.IdentifiersEntry = append(c.hooks.IdentifiersEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `identifiersentry.Intercept(f(g(h())))`.
func (c *IdentifiersEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.IdentifiersEntry = append(c.inters.IdentifiersEntry, interceptors...)
}

// Create returns a builder for creating a IdentifiersEntry entity.
func (c *IdentifiersEntryClient) Create() *IdentifiersEntryCreate {
	mutation := newIdentifiersEntryMutation(c.config, OpCreate)
	return &IdentifiersEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IdentifiersEntry entities.
func (c *IdentifiersEntryClient) CreateBulk(builders ...*IdentifiersEntryCreate) *IdentifiersEntryCreateBulk {
	return &IdentifiersEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IdentifiersEntryClient) MapCreateBulk(slice any, setFunc func(*IdentifiersEntryCreate, int)) *IdentifiersEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IdentifiersEntryCreateBulk{err: fmt.Errorf("calling to IdentifiersEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IdentifiersEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IdentifiersEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IdentifiersEntry.
func (c *IdentifiersEntryClient) Update() *IdentifiersEntryUpdate {
	mutation := newIdentifiersEntryMutation(c.config, OpUpdate)
	return &IdentifiersEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IdentifiersEntryClient) UpdateOne(ie *IdentifiersEntry) *IdentifiersEntryUpdateOne {
	mutation := newIdentifiersEntryMutation(c.config, OpUpdateOne, withIdentifiersEntry(ie))
	return &IdentifiersEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IdentifiersEntryClient) UpdateOneID(id uuid.UUID) *IdentifiersEntryUpdateOne {
	mutation := newIdentifiersEntryMutation(c.config, OpUpdateOne, withIdentifiersEntryID(id))
	return &IdentifiersEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IdentifiersEntry.
func (c *IdentifiersEntryClient) Delete() *IdentifiersEntryDelete {
	mutation := newIdentifiersEntryMutation(c.config, OpDelete)
	return &IdentifiersEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IdentifiersEntryClient) DeleteOne(ie *IdentifiersEntry) *IdentifiersEntryDeleteOne {
	return c.DeleteOneID(ie.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IdentifiersEntryClient) DeleteOneID(id uuid.UUID) *IdentifiersEntryDeleteOne {
	builder := c.Delete().Where(identifiersentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IdentifiersEntryDeleteOne{builder}
}

// Query returns a query builder for IdentifiersEntry.
func (c *IdentifiersEntryClient) Query() *IdentifiersEntryQuery {
	return &IdentifiersEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIdentifiersEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a IdentifiersEntry entity by its id.
func (c *IdentifiersEntryClient) Get(ctx context.Context, id uuid.UUID) (*IdentifiersEntry, error) {
	return c.Query().Where(identifiersentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IdentifiersEntryClient) GetX(ctx context.Context, id uuid.UUID) *IdentifiersEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a IdentifiersEntry.
func (c *IdentifiersEntryClient) QueryDocument(ie *IdentifiersEntry) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(identifiersentry.Table, identifiersentry.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, identifiersentry.DocumentTable, identifiersentry.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a IdentifiersEntry.
func (c *IdentifiersEntryClient) QueryNodes(ie *IdentifiersEntry) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ie.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(identifiersentry.Table, identifiersentry.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, identifiersentry.NodesTable, identifiersentry.NodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ie.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IdentifiersEntryClient) Hooks() []Hook {
	return c.hooks.IdentifiersEntry
}

// Interceptors returns the client interceptors.
func (c *IdentifiersEntryClient) Interceptors() []Interceptor {
	return c.inters.IdentifiersEntry
}

func (c *IdentifiersEntryClient) mutate(ctx context.Context, m *IdentifiersEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IdentifiersEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IdentifiersEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IdentifiersEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IdentifiersEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IdentifiersEntry mutation op: %q", m.Op())
	}
}

// MetadataClient is a client for the Metadata schema.
type MetadataClient struct {
	config
}

// NewMetadataClient returns a client for the Metadata from the given config.
func NewMetadataClient(c config) *MetadataClient {
	return &MetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metadata.Hooks(f(g(h())))`.
func (c *MetadataClient) Use(hooks ...Hook) {
	c.hooks.Metadata = append(c.hooks.Metadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `metadata.Intercept(f(g(h())))`.
func (c *MetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.Metadata = append(c.inters.Metadata, interceptors...)
}

// Create returns a builder for creating a Metadata entity.
func (c *MetadataClient) Create() *MetadataCreate {
	mutation := newMetadataMutation(c.config, OpCreate)
	return &MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metadata entities.
func (c *MetadataClient) CreateBulk(builders ...*MetadataCreate) *MetadataCreateBulk {
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MetadataClient) MapCreateBulk(slice any, setFunc func(*MetadataCreate, int)) *MetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MetadataCreateBulk{err: fmt.Errorf("calling to MetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metadata.
func (c *MetadataClient) Update() *MetadataUpdate {
	mutation := newMetadataMutation(c.config, OpUpdate)
	return &MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetadataClient) UpdateOne(m *Metadata) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadata(m))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetadataClient) UpdateOneID(id uuid.UUID) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadataID(id))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metadata.
func (c *MetadataClient) Delete() *MetadataDelete {
	mutation := newMetadataMutation(c.config, OpDelete)
	return &MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MetadataClient) DeleteOne(m *Metadata) *MetadataDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MetadataClient) DeleteOneID(id uuid.UUID) *MetadataDeleteOne {
	builder := c.Delete().Where(metadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetadataDeleteOne{builder}
}

// Query returns a query builder for Metadata.
func (c *MetadataClient) Query() *MetadataQuery {
	return &MetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a Metadata entity by its id.
func (c *MetadataClient) Get(ctx context.Context, id uuid.UUID) (*Metadata, error) {
	return c.Query().Where(metadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetadataClient) GetX(ctx context.Context, id uuid.UUID) *Metadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a Metadata.
func (c *MetadataClient) QueryDocument(m *Metadata) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, metadata.DocumentTable, metadata.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTools queries the tools edge of a Metadata.
func (c *MetadataClient) QueryTools(m *Metadata) *ToolQuery {
	query := (&ToolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(tool.Table, tool.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metadata.ToolsTable, metadata.ToolsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthors queries the authors edge of a Metadata.
func (c *MetadataClient) QueryAuthors(m *Metadata) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metadata.AuthorsTable, metadata.AuthorsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocumentTypes queries the document_types edge of a Metadata.
func (c *MetadataClient) QueryDocumentTypes(m *Metadata) *DocumentTypeQuery {
	query := (&DocumentTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(documenttype.Table, documenttype.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metadata.DocumentTypesTable, metadata.DocumentTypesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySourceData queries the source_data edge of a Metadata.
func (c *MetadataClient) QuerySourceData(m *Metadata) *SourceDataQuery {
	query := (&SourceDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(sourcedata.Table, sourcedata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metadata.SourceDataTable, metadata.SourceDataColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetadataClient) Hooks() []Hook {
	return c.hooks.Metadata
}

// Interceptors returns the client interceptors.
func (c *MetadataClient) Interceptors() []Interceptor {
	return c.inters.Metadata
}

func (c *MetadataClient) mutate(ctx context.Context, m *MetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Metadata mutation op: %q", m.Op())
	}
}

// NodeClient is a client for the Node schema.
type NodeClient struct {
	config
}

// NewNodeClient returns a client for the Node from the given config.
func NewNodeClient(c config) *NodeClient {
	return &NodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `node.Hooks(f(g(h())))`.
func (c *NodeClient) Use(hooks ...Hook) {
	c.hooks.Node = append(c.hooks.Node, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `node.Intercept(f(g(h())))`.
func (c *NodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Node = append(c.inters.Node, interceptors...)
}

// Create returns a builder for creating a Node entity.
func (c *NodeClient) Create() *NodeCreate {
	mutation := newNodeMutation(c.config, OpCreate)
	return &NodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Node entities.
func (c *NodeClient) CreateBulk(builders ...*NodeCreate) *NodeCreateBulk {
	return &NodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NodeClient) MapCreateBulk(slice any, setFunc func(*NodeCreate, int)) *NodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NodeCreateBulk{err: fmt.Errorf("calling to NodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Node.
func (c *NodeClient) Update() *NodeUpdate {
	mutation := newNodeMutation(c.config, OpUpdate)
	return &NodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NodeClient) UpdateOne(n *Node) *NodeUpdateOne {
	mutation := newNodeMutation(c.config, OpUpdateOne, withNode(n))
	return &NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NodeClient) UpdateOneID(id uuid.UUID) *NodeUpdateOne {
	mutation := newNodeMutation(c.config, OpUpdateOne, withNodeID(id))
	return &NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Node.
func (c *NodeClient) Delete() *NodeDelete {
	mutation := newNodeMutation(c.config, OpDelete)
	return &NodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NodeClient) DeleteOne(n *Node) *NodeDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NodeClient) DeleteOneID(id uuid.UUID) *NodeDeleteOne {
	builder := c.Delete().Where(node.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NodeDeleteOne{builder}
}

// Query returns a query builder for Node.
func (c *NodeClient) Query() *NodeQuery {
	return &NodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNode},
		inters: c.Interceptors(),
	}
}

// Get returns a Node entity by its id.
func (c *NodeClient) Get(ctx context.Context, id uuid.UUID) (*Node, error) {
	return c.Query().Where(node.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NodeClient) GetX(ctx context.Context, id uuid.UUID) *Node {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a Node.
func (c *NodeClient) QueryDocument(n *Node) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, node.DocumentTable, node.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnnotations queries the annotations edge of a Node.
func (c *NodeClient) QueryAnnotations(n *Node) *AnnotationQuery {
	query := (&AnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(annotation.Table, annotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.AnnotationsTable, node.AnnotationsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuppliers queries the suppliers edge of a Node.
func (c *NodeClient) QuerySuppliers(n *Node) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.SuppliersTable, node.SuppliersColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOriginators queries the originators edge of a Node.
func (c *NodeClient) QueryOriginators(n *Node) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.OriginatorsTable, node.OriginatorsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExternalReferences queries the external_references edge of a Node.
func (c *NodeClient) QueryExternalReferences(n *Node) *ExternalReferenceQuery {
	query := (&ExternalReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(externalreference.Table, externalreference.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, node.ExternalReferencesTable, node.ExternalReferencesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryPurpose queries the primary_purpose edge of a Node.
func (c *NodeClient) QueryPrimaryPurpose(n *Node) *PurposeQuery {
	query := (&PurposeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(purpose.Table, purpose.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.PrimaryPurposeTable, node.PrimaryPurposeColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToNodes queries the to_nodes edge of a Node.
func (c *NodeClient) QueryToNodes(n *Node) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, node.ToNodesTable, node.ToNodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a Node.
func (c *NodeClient) QueryNodes(n *Node) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, node.NodesTable, node.NodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHashes queries the hashes edge of a Node.
func (c *NodeClient) QueryHashes(n *Node) *HashesEntryQuery {
	query := (&HashesEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(hashesentry.Table, hashesentry.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, node.HashesTable, node.HashesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIdentifiers queries the identifiers edge of a Node.
func (c *NodeClient) QueryIdentifiers(n *Node) *IdentifiersEntryQuery {
	query := (&IdentifiersEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(identifiersentry.Table, identifiersentry.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, node.IdentifiersTable, node.IdentifiersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProperties queries the properties edge of a Node.
func (c *NodeClient) QueryProperties(n *Node) *PropertyQuery {
	query := (&PropertyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(property.Table, property.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.PropertiesTable, node.PropertiesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodeLists queries the node_lists edge of a Node.
func (c *NodeClient) QueryNodeLists(n *Node) *NodeListQuery {
	query := (&NodeListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(nodelist.Table, nodelist.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, node.NodeListsTable, node.NodeListsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEdgeTypes queries the edge_types edge of a Node.
func (c *NodeClient) QueryEdgeTypes(n *Node) *EdgeTypeQuery {
	query := (&EdgeTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(edgetype.Table, edgetype.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, node.EdgeTypesTable, node.EdgeTypesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NodeClient) Hooks() []Hook {
	return c.hooks.Node
}

// Interceptors returns the client interceptors.
func (c *NodeClient) Interceptors() []Interceptor {
	return c.inters.Node
}

func (c *NodeClient) mutate(ctx context.Context, m *NodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Node mutation op: %q", m.Op())
	}
}

// NodeListClient is a client for the NodeList schema.
type NodeListClient struct {
	config
}

// NewNodeListClient returns a client for the NodeList from the given config.
func NewNodeListClient(c config) *NodeListClient {
	return &NodeListClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nodelist.Hooks(f(g(h())))`.
func (c *NodeListClient) Use(hooks ...Hook) {
	c.hooks.NodeList = append(c.hooks.NodeList, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nodelist.Intercept(f(g(h())))`.
func (c *NodeListClient) Intercept(interceptors ...Interceptor) {
	c.inters.NodeList = append(c.inters.NodeList, interceptors...)
}

// Create returns a builder for creating a NodeList entity.
func (c *NodeListClient) Create() *NodeListCreate {
	mutation := newNodeListMutation(c.config, OpCreate)
	return &NodeListCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NodeList entities.
func (c *NodeListClient) CreateBulk(builders ...*NodeListCreate) *NodeListCreateBulk {
	return &NodeListCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NodeListClient) MapCreateBulk(slice any, setFunc func(*NodeListCreate, int)) *NodeListCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NodeListCreateBulk{err: fmt.Errorf("calling to NodeListClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NodeListCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NodeListCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NodeList.
func (c *NodeListClient) Update() *NodeListUpdate {
	mutation := newNodeListMutation(c.config, OpUpdate)
	return &NodeListUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NodeListClient) UpdateOne(nl *NodeList) *NodeListUpdateOne {
	mutation := newNodeListMutation(c.config, OpUpdateOne, withNodeList(nl))
	return &NodeListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NodeListClient) UpdateOneID(id uuid.UUID) *NodeListUpdateOne {
	mutation := newNodeListMutation(c.config, OpUpdateOne, withNodeListID(id))
	return &NodeListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NodeList.
func (c *NodeListClient) Delete() *NodeListDelete {
	mutation := newNodeListMutation(c.config, OpDelete)
	return &NodeListDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NodeListClient) DeleteOne(nl *NodeList) *NodeListDeleteOne {
	return c.DeleteOneID(nl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NodeListClient) DeleteOneID(id uuid.UUID) *NodeListDeleteOne {
	builder := c.Delete().Where(nodelist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NodeListDeleteOne{builder}
}

// Query returns a query builder for NodeList.
func (c *NodeListClient) Query() *NodeListQuery {
	return &NodeListQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNodeList},
		inters: c.Interceptors(),
	}
}

// Get returns a NodeList entity by its id.
func (c *NodeListClient) Get(ctx context.Context, id uuid.UUID) (*NodeList, error) {
	return c.Query().Where(nodelist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NodeListClient) GetX(ctx context.Context, id uuid.UUID) *NodeList {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a NodeList.
func (c *NodeListClient) QueryDocument(nl *NodeList) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodelist.Table, nodelist.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, nodelist.DocumentTable, nodelist.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(nl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEdgeTypes queries the edge_types edge of a NodeList.
func (c *NodeListClient) QueryEdgeTypes(nl *NodeList) *EdgeTypeQuery {
	query := (&EdgeTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodelist.Table, nodelist.FieldID, id),
			sqlgraph.To(edgetype.Table, edgetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, nodelist.EdgeTypesTable, nodelist.EdgeTypesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(nl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a NodeList.
func (c *NodeListClient) QueryNodes(nl *NodeList) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodelist.Table, nodelist.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, nodelist.NodesTable, nodelist.NodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(nl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NodeListClient) Hooks() []Hook {
	return c.hooks.NodeList
}

// Interceptors returns the client interceptors.
func (c *NodeListClient) Interceptors() []Interceptor {
	return c.inters.NodeList
}

func (c *NodeListClient) mutate(ctx context.Context, m *NodeListMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NodeListCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NodeListUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NodeListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NodeListDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NodeList mutation op: %q", m.Op())
	}
}

// PersonClient is a client for the Person schema.
type PersonClient struct {
	config
}

// NewPersonClient returns a client for the Person from the given config.
func NewPersonClient(c config) *PersonClient {
	return &PersonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `person.Hooks(f(g(h())))`.
func (c *PersonClient) Use(hooks ...Hook) {
	c.hooks.Person = append(c.hooks.Person, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `person.Intercept(f(g(h())))`.
func (c *PersonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Person = append(c.inters.Person, interceptors...)
}

// Create returns a builder for creating a Person entity.
func (c *PersonClient) Create() *PersonCreate {
	mutation := newPersonMutation(c.config, OpCreate)
	return &PersonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Person entities.
func (c *PersonClient) CreateBulk(builders ...*PersonCreate) *PersonCreateBulk {
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonClient) MapCreateBulk(slice any, setFunc func(*PersonCreate, int)) *PersonCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonCreateBulk{err: fmt.Errorf("calling to PersonClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Person.
func (c *PersonClient) Update() *PersonUpdate {
	mutation := newPersonMutation(c.config, OpUpdate)
	return &PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonClient) UpdateOne(pe *Person) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPerson(pe))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonClient) UpdateOneID(id uuid.UUID) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPersonID(id))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Person.
func (c *PersonClient) Delete() *PersonDelete {
	mutation := newPersonMutation(c.config, OpDelete)
	return &PersonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonClient) DeleteOne(pe *Person) *PersonDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonClient) DeleteOneID(id uuid.UUID) *PersonDeleteOne {
	builder := c.Delete().Where(person.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonDeleteOne{builder}
}

// Query returns a query builder for Person.
func (c *PersonClient) Query() *PersonQuery {
	return &PersonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePerson},
		inters: c.Interceptors(),
	}
}

// Get returns a Person entity by its id.
func (c *PersonClient) Get(ctx context.Context, id uuid.UUID) (*Person, error) {
	return c.Query().Where(person.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonClient) GetX(ctx context.Context, id uuid.UUID) *Person {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a Person.
func (c *PersonClient) QueryDocument(pe *Person) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, person.DocumentTable, person.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContactOwner queries the contact_owner edge of a Person.
func (c *PersonClient) QueryContactOwner(pe *Person) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, person.ContactOwnerTable, person.ContactOwnerColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContacts queries the contacts edge of a Person.
func (c *PersonClient) QueryContacts(pe *Person) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.ContactsTable, person.ContactsColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a Person.
func (c *PersonClient) QueryMetadata(pe *Person) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, person.MetadataTable, person.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNode queries the node edge of a Person.
func (c *PersonClient) QueryNode(pe *Person) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, person.NodeTable, person.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonClient) Hooks() []Hook {
	return c.hooks.Person
}

// Interceptors returns the client interceptors.
func (c *PersonClient) Interceptors() []Interceptor {
	return c.inters.Person
}

func (c *PersonClient) mutate(ctx context.Context, m *PersonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Person mutation op: %q", m.Op())
	}
}

// PropertyClient is a client for the Property schema.
type PropertyClient struct {
	config
}

// NewPropertyClient returns a client for the Property from the given config.
func NewPropertyClient(c config) *PropertyClient {
	return &PropertyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `property.Hooks(f(g(h())))`.
func (c *PropertyClient) Use(hooks ...Hook) {
	c.hooks.Property = append(c.hooks.Property, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `property.Intercept(f(g(h())))`.
func (c *PropertyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Property = append(c.inters.Property, interceptors...)
}

// Create returns a builder for creating a Property entity.
func (c *PropertyClient) Create() *PropertyCreate {
	mutation := newPropertyMutation(c.config, OpCreate)
	return &PropertyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Property entities.
func (c *PropertyClient) CreateBulk(builders ...*PropertyCreate) *PropertyCreateBulk {
	return &PropertyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PropertyClient) MapCreateBulk(slice any, setFunc func(*PropertyCreate, int)) *PropertyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PropertyCreateBulk{err: fmt.Errorf("calling to PropertyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PropertyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PropertyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Property.
func (c *PropertyClient) Update() *PropertyUpdate {
	mutation := newPropertyMutation(c.config, OpUpdate)
	return &PropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PropertyClient) UpdateOne(pr *Property) *PropertyUpdateOne {
	mutation := newPropertyMutation(c.config, OpUpdateOne, withProperty(pr))
	return &PropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PropertyClient) UpdateOneID(id uuid.UUID) *PropertyUpdateOne {
	mutation := newPropertyMutation(c.config, OpUpdateOne, withPropertyID(id))
	return &PropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Property.
func (c *PropertyClient) Delete() *PropertyDelete {
	mutation := newPropertyMutation(c.config, OpDelete)
	return &PropertyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PropertyClient) DeleteOne(pr *Property) *PropertyDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PropertyClient) DeleteOneID(id uuid.UUID) *PropertyDeleteOne {
	builder := c.Delete().Where(property.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PropertyDeleteOne{builder}
}

// Query returns a query builder for Property.
func (c *PropertyClient) Query() *PropertyQuery {
	return &PropertyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProperty},
		inters: c.Interceptors(),
	}
}

// Get returns a Property entity by its id.
func (c *PropertyClient) Get(ctx context.Context, id uuid.UUID) (*Property, error) {
	return c.Query().Where(property.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PropertyClient) GetX(ctx context.Context, id uuid.UUID) *Property {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a Property.
func (c *PropertyClient) QueryDocument(pr *Property) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(property.Table, property.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, property.DocumentTable, property.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNode queries the node edge of a Property.
func (c *PropertyClient) QueryNode(pr *Property) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(property.Table, property.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, property.NodeTable, property.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PropertyClient) Hooks() []Hook {
	return c.hooks.Property
}

// Interceptors returns the client interceptors.
func (c *PropertyClient) Interceptors() []Interceptor {
	return c.inters.Property
}

func (c *PropertyClient) mutate(ctx context.Context, m *PropertyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PropertyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PropertyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Property mutation op: %q", m.Op())
	}
}

// PurposeClient is a client for the Purpose schema.
type PurposeClient struct {
	config
}

// NewPurposeClient returns a client for the Purpose from the given config.
func NewPurposeClient(c config) *PurposeClient {
	return &PurposeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `purpose.Hooks(f(g(h())))`.
func (c *PurposeClient) Use(hooks ...Hook) {
	c.hooks.Purpose = append(c.hooks.Purpose, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `purpose.Intercept(f(g(h())))`.
func (c *PurposeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Purpose = append(c.inters.Purpose, interceptors...)
}

// Create returns a builder for creating a Purpose entity.
func (c *PurposeClient) Create() *PurposeCreate {
	mutation := newPurposeMutation(c.config, OpCreate)
	return &PurposeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Purpose entities.
func (c *PurposeClient) CreateBulk(builders ...*PurposeCreate) *PurposeCreateBulk {
	return &PurposeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PurposeClient) MapCreateBulk(slice any, setFunc func(*PurposeCreate, int)) *PurposeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PurposeCreateBulk{err: fmt.Errorf("calling to PurposeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PurposeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PurposeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Purpose.
func (c *PurposeClient) Update() *PurposeUpdate {
	mutation := newPurposeMutation(c.config, OpUpdate)
	return &PurposeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PurposeClient) UpdateOne(pu *Purpose) *PurposeUpdateOne {
	mutation := newPurposeMutation(c.config, OpUpdateOne, withPurpose(pu))
	return &PurposeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PurposeClient) UpdateOneID(id int) *PurposeUpdateOne {
	mutation := newPurposeMutation(c.config, OpUpdateOne, withPurposeID(id))
	return &PurposeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Purpose.
func (c *PurposeClient) Delete() *PurposeDelete {
	mutation := newPurposeMutation(c.config, OpDelete)
	return &PurposeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PurposeClient) DeleteOne(pu *Purpose) *PurposeDeleteOne {
	return c.DeleteOneID(pu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PurposeClient) DeleteOneID(id int) *PurposeDeleteOne {
	builder := c.Delete().Where(purpose.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PurposeDeleteOne{builder}
}

// Query returns a query builder for Purpose.
func (c *PurposeClient) Query() *PurposeQuery {
	return &PurposeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePurpose},
		inters: c.Interceptors(),
	}
}

// Get returns a Purpose entity by its id.
func (c *PurposeClient) Get(ctx context.Context, id int) (*Purpose, error) {
	return c.Query().Where(purpose.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PurposeClient) GetX(ctx context.Context, id int) *Purpose {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a Purpose.
func (c *PurposeClient) QueryDocument(pu *Purpose) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(purpose.Table, purpose.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, purpose.DocumentTable, purpose.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNode queries the node edge of a Purpose.
func (c *PurposeClient) QueryNode(pu *Purpose) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(purpose.Table, purpose.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, purpose.NodeTable, purpose.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PurposeClient) Hooks() []Hook {
	return c.hooks.Purpose
}

// Interceptors returns the client interceptors.
func (c *PurposeClient) Interceptors() []Interceptor {
	return c.inters.Purpose
}

func (c *PurposeClient) mutate(ctx context.Context, m *PurposeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PurposeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PurposeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PurposeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PurposeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Purpose mutation op: %q", m.Op())
	}
}

// SourceDataClient is a client for the SourceData schema.
type SourceDataClient struct {
	config
}

// NewSourceDataClient returns a client for the SourceData from the given config.
func NewSourceDataClient(c config) *SourceDataClient {
	return &SourceDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcedata.Hooks(f(g(h())))`.
func (c *SourceDataClient) Use(hooks ...Hook) {
	c.hooks.SourceData = append(c.hooks.SourceData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcedata.Intercept(f(g(h())))`.
func (c *SourceDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceData = append(c.inters.SourceData, interceptors...)
}

// Create returns a builder for creating a SourceData entity.
func (c *SourceDataClient) Create() *SourceDataCreate {
	mutation := newSourceDataMutation(c.config, OpCreate)
	return &SourceDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceData entities.
func (c *SourceDataClient) CreateBulk(builders ...*SourceDataCreate) *SourceDataCreateBulk {
	return &SourceDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceDataClient) MapCreateBulk(slice any, setFunc func(*SourceDataCreate, int)) *SourceDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceDataCreateBulk{err: fmt.Errorf("calling to SourceDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceData.
func (c *SourceDataClient) Update() *SourceDataUpdate {
	mutation := newSourceDataMutation(c.config, OpUpdate)
	return &SourceDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceDataClient) UpdateOne(sd *SourceData) *SourceDataUpdateOne {
	mutation := newSourceDataMutation(c.config, OpUpdateOne, withSourceData(sd))
	return &SourceDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceDataClient) UpdateOneID(id uuid.UUID) *SourceDataUpdateOne {
	mutation := newSourceDataMutation(c.config, OpUpdateOne, withSourceDataID(id))
	return &SourceDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceData.
func (c *SourceDataClient) Delete() *SourceDataDelete {
	mutation := newSourceDataMutation(c.config, OpDelete)
	return &SourceDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceDataClient) DeleteOne(sd *SourceData) *SourceDataDeleteOne {
	return c.DeleteOneID(sd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceDataClient) DeleteOneID(id uuid.UUID) *SourceDataDeleteOne {
	builder := c.Delete().Where(sourcedata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceDataDeleteOne{builder}
}

// Query returns a query builder for SourceData.
func (c *SourceDataClient) Query() *SourceDataQuery {
	return &SourceDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceData},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceData entity by its id.
func (c *SourceDataClient) Get(ctx context.Context, id uuid.UUID) (*SourceData, error) {
	return c.Query().Where(sourcedata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceDataClient) GetX(ctx context.Context, id uuid.UUID) *SourceData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a SourceData.
func (c *SourceDataClient) QueryDocument(sd *SourceData) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcedata.Table, sourcedata.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sourcedata.DocumentTable, sourcedata.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(sd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a SourceData.
func (c *SourceDataClient) QueryMetadata(sd *SourceData) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcedata.Table, sourcedata.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sourcedata.MetadataTable, sourcedata.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(sd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceDataClient) Hooks() []Hook {
	return c.hooks.SourceData
}

// Interceptors returns the client interceptors.
func (c *SourceDataClient) Interceptors() []Interceptor {
	return c.inters.SourceData
}

func (c *SourceDataClient) mutate(ctx context.Context, m *SourceDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceData mutation op: %q", m.Op())
	}
}

// ToolClient is a client for the Tool schema.
type ToolClient struct {
	config
}

// NewToolClient returns a client for the Tool from the given config.
func NewToolClient(c config) *ToolClient {
	return &ToolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tool.Hooks(f(g(h())))`.
func (c *ToolClient) Use(hooks ...Hook) {
	c.hooks.Tool = append(c.hooks.Tool, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tool.Intercept(f(g(h())))`.
func (c *ToolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tool = append(c.inters.Tool, interceptors...)
}

// Create returns a builder for creating a Tool entity.
func (c *ToolClient) Create() *ToolCreate {
	mutation := newToolMutation(c.config, OpCreate)
	return &ToolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tool entities.
func (c *ToolClient) CreateBulk(builders ...*ToolCreate) *ToolCreateBulk {
	return &ToolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ToolClient) MapCreateBulk(slice any, setFunc func(*ToolCreate, int)) *ToolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ToolCreateBulk{err: fmt.Errorf("calling to ToolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ToolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ToolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tool.
func (c *ToolClient) Update() *ToolUpdate {
	mutation := newToolMutation(c.config, OpUpdate)
	return &ToolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ToolClient) UpdateOne(t *Tool) *ToolUpdateOne {
	mutation := newToolMutation(c.config, OpUpdateOne, withTool(t))
	return &ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ToolClient) UpdateOneID(id uuid.UUID) *ToolUpdateOne {
	mutation := newToolMutation(c.config, OpUpdateOne, withToolID(id))
	return &ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tool.
func (c *ToolClient) Delete() *ToolDelete {
	mutation := newToolMutation(c.config, OpDelete)
	return &ToolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ToolClient) DeleteOne(t *Tool) *ToolDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ToolClient) DeleteOneID(id uuid.UUID) *ToolDeleteOne {
	builder := c.Delete().Where(tool.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ToolDeleteOne{builder}
}

// Query returns a query builder for Tool.
func (c *ToolClient) Query() *ToolQuery {
	return &ToolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTool},
		inters: c.Interceptors(),
	}
}

// Get returns a Tool entity by its id.
func (c *ToolClient) Get(ctx context.Context, id uuid.UUID) (*Tool, error) {
	return c.Query().Where(tool.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ToolClient) GetX(ctx context.Context, id uuid.UUID) *Tool {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDocument queries the document edge of a Tool.
func (c *ToolClient) QueryDocument(t *Tool) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tool.Table, tool.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tool.DocumentTable, tool.DocumentColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a Tool.
func (c *ToolClient) QueryMetadata(t *Tool) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tool.Table, tool.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tool.MetadataTable, tool.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ToolClient) Hooks() []Hook {
	return c.hooks.Tool
}

// Interceptors returns the client interceptors.
func (c *ToolClient) Interceptors() []Interceptor {
	return c.inters.Tool
}

func (c *ToolClient) mutate(ctx context.Context, m *ToolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ToolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ToolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ToolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ToolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tool mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Annotation, Document, DocumentType, EdgeType, ExternalReference, HashesEntry,
		IdentifiersEntry, Metadata, Node, NodeList, Person, Property, Purpose,
		SourceData, Tool []ent.Hook
	}
	inters struct {
		Annotation, Document, DocumentType, EdgeType, ExternalReference, HashesEntry,
		IdentifiersEntry, Metadata, Node, NodeList, Person, Property, Purpose,
		SourceData, Tool []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
