// Code generated by ent, DO NOT EDIT.
// --------------------------------------------------------------
// SPDX-FileCopyrightText: Copyright Â© 2024 The Protobom Authors
// SPDX-FileType: SOURCE
// SPDX-License-Identifier: Apache-2.0
// --------------------------------------------------------------

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/protobom/protobom/pkg/sbom"
	"github.com/protobom/storage/internal/backends/ent/annotation"
	"github.com/protobom/storage/internal/backends/ent/document"
	"github.com/protobom/storage/internal/backends/ent/documenttype"
	"github.com/protobom/storage/internal/backends/ent/edgetype"
	"github.com/protobom/storage/internal/backends/ent/externalreference"
	"github.com/protobom/storage/internal/backends/ent/hashesentry"
	"github.com/protobom/storage/internal/backends/ent/identifiersentry"
	"github.com/protobom/storage/internal/backends/ent/metadata"
	"github.com/protobom/storage/internal/backends/ent/node"
	"github.com/protobom/storage/internal/backends/ent/nodelist"
	"github.com/protobom/storage/internal/backends/ent/person"
	"github.com/protobom/storage/internal/backends/ent/predicate"
	"github.com/protobom/storage/internal/backends/ent/property"
	"github.com/protobom/storage/internal/backends/ent/purpose"
	"github.com/protobom/storage/internal/backends/ent/sourcedata"
	"github.com/protobom/storage/internal/backends/ent/tool"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnnotation        = "Annotation"
	TypeDocument          = "Document"
	TypeDocumentType      = "DocumentType"
	TypeEdgeType          = "EdgeType"
	TypeExternalReference = "ExternalReference"
	TypeHashesEntry       = "HashesEntry"
	TypeIdentifiersEntry  = "IdentifiersEntry"
	TypeMetadata          = "Metadata"
	TypeNode              = "Node"
	TypeNodeList          = "NodeList"
	TypePerson            = "Person"
	TypeProperty          = "Property"
	TypePurpose           = "Purpose"
	TypeSourceData        = "SourceData"
	TypeTool              = "Tool"
)

// AnnotationMutation represents an operation that mutates the Annotation nodes in the graph.
type AnnotationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	value           *string
	is_unique       *bool
	clearedFields   map[string]struct{}
	document        *uuid.UUID
	cleareddocument bool
	node            *uuid.UUID
	clearednode     bool
	done            bool
	oldValue        func(context.Context) (*Annotation, error)
	predicates      []predicate.Annotation
}

var _ ent.Mutation = (*AnnotationMutation)(nil)

// annotationOption allows management of the mutation configuration using functional options.
type annotationOption func(*AnnotationMutation)

// newAnnotationMutation creates new mutation for the Annotation entity.
func newAnnotationMutation(c config, op Op, opts ...annotationOption) *AnnotationMutation {
	m := &AnnotationMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnotation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnotationID sets the ID field of the mutation.
func withAnnotationID(id int) annotationOption {
	return func(m *AnnotationMutation) {
		var (
			err   error
			once  sync.Once
			value *Annotation
		)
		m.oldValue = func(ctx context.Context) (*Annotation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Annotation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnotation sets the old Annotation of the mutation.
func withAnnotation(node *Annotation) annotationOption {
	return func(m *AnnotationMutation) {
		m.oldValue = func(context.Context) (*Annotation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnotationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnotationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnotationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnotationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Annotation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDocumentID sets the "document_id" field.
func (m *AnnotationMutation) SetDocumentID(u uuid.UUID) {
	m.document = &u
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *AnnotationMutation) DocumentID() (r uuid.UUID, exists bool) {
	v := m.document
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldDocumentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ClearDocumentID clears the value of the "document_id" field.
func (m *AnnotationMutation) ClearDocumentID() {
	m.document = nil
	m.clearedFields[annotation.FieldDocumentID] = struct{}{}
}

// DocumentIDCleared returns if the "document_id" field was cleared in this mutation.
func (m *AnnotationMutation) DocumentIDCleared() bool {
	_, ok := m.clearedFields[annotation.FieldDocumentID]
	return ok
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *AnnotationMutation) ResetDocumentID() {
	m.document = nil
	delete(m.clearedFields, annotation.FieldDocumentID)
}

// SetNodeID sets the "node_id" field.
func (m *AnnotationMutation) SetNodeID(u uuid.UUID) {
	m.node = &u
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *AnnotationMutation) NodeID() (r uuid.UUID, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldNodeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ClearNodeID clears the value of the "node_id" field.
func (m *AnnotationMutation) ClearNodeID() {
	m.node = nil
	m.clearedFields[annotation.FieldNodeID] = struct{}{}
}

// NodeIDCleared returns if the "node_id" field was cleared in this mutation.
func (m *AnnotationMutation) NodeIDCleared() bool {
	_, ok := m.clearedFields[annotation.FieldNodeID]
	return ok
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *AnnotationMutation) ResetNodeID() {
	m.node = nil
	delete(m.clearedFields, annotation.FieldNodeID)
}

// SetName sets the "name" field.
func (m *AnnotationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AnnotationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AnnotationMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *AnnotationMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *AnnotationMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AnnotationMutation) ResetValue() {
	m.value = nil
}

// SetIsUnique sets the "is_unique" field.
func (m *AnnotationMutation) SetIsUnique(b bool) {
	m.is_unique = &b
}

// IsUnique returns the value of the "is_unique" field in the mutation.
func (m *AnnotationMutation) IsUnique() (r bool, exists bool) {
	v := m.is_unique
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUnique returns the old "is_unique" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldIsUnique(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUnique is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUnique requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUnique: %w", err)
	}
	return oldValue.IsUnique, nil
}

// ResetIsUnique resets all changes to the "is_unique" field.
func (m *AnnotationMutation) ResetIsUnique() {
	m.is_unique = nil
}

// ClearDocument clears the "document" edge to the Document entity.
func (m *AnnotationMutation) ClearDocument() {
	m.cleareddocument = true
	m.clearedFields[annotation.FieldDocumentID] = struct{}{}
}

// DocumentCleared reports if the "document" edge to the Document entity was cleared.
func (m *AnnotationMutation) DocumentCleared() bool {
	return m.DocumentIDCleared() || m.cleareddocument
}

// DocumentIDs returns the "document" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DocumentID instead. It exists only for internal usage by the builders.
func (m *AnnotationMutation) DocumentIDs() (ids []uuid.UUID) {
	if id := m.document; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocument resets all changes to the "document" edge.
func (m *AnnotationMutation) ResetDocument() {
	m.document = nil
	m.cleareddocument = false
}

// ClearNode clears the "node" edge to the Node entity.
func (m *AnnotationMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[annotation.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *AnnotationMutation) NodeCleared() bool {
	return m.NodeIDCleared() || m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *AnnotationMutation) NodeIDs() (ids []uuid.UUID) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *AnnotationMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the AnnotationMutation builder.
func (m *AnnotationMutation) Where(ps ...predicate.Annotation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnnotationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnnotationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Annotation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnnotationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnnotationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Annotation).
func (m *AnnotationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnotationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.document != nil {
		fields = append(fields, annotation.FieldDocumentID)
	}
	if m.node != nil {
		fields = append(fields, annotation.FieldNodeID)
	}
	if m.name != nil {
		fields = append(fields, annotation.FieldName)
	}
	if m.value != nil {
		fields = append(fields, annotation.FieldValue)
	}
	if m.is_unique != nil {
		fields = append(fields, annotation.FieldIsUnique)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnotationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case annotation.FieldDocumentID:
		return m.DocumentID()
	case annotation.FieldNodeID:
		return m.NodeID()
	case annotation.FieldName:
		return m.Name()
	case annotation.FieldValue:
		return m.Value()
	case annotation.FieldIsUnique:
		return m.IsUnique()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnotationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case annotation.FieldDocumentID:
		return m.OldDocumentID(ctx)
	case annotation.FieldNodeID:
		return m.OldNodeID(ctx)
	case annotation.FieldName:
		return m.OldName(ctx)
	case annotation.FieldValue:
		return m.OldValue(ctx)
	case annotation.FieldIsUnique:
		return m.OldIsUnique(ctx)
	}
	return nil, fmt.Errorf("unknown Annotation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnotationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case annotation.FieldDocumentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	case annotation.FieldNodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case annotation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case annotation.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case annotation.FieldIsUnique:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUnique(v)
		return nil
	}
	return fmt.Errorf("unknown Annotation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnotationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnotationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnotationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Annotation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnotationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(annotation.FieldDocumentID) {
		fields = append(fields, annotation.FieldDocumentID)
	}
	if m.FieldCleared(annotation.FieldNodeID) {
		fields = append(fields, annotation.FieldNodeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnotationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnotationMutation) ClearField(name string) error {
	switch name {
	case annotation.FieldDocumentID:
		m.ClearDocumentID()
		return nil
	case annotation.FieldNodeID:
		m.ClearNodeID()
		return nil
	}
	return fmt.Errorf("unknown Annotation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnotationMutation) ResetField(name string) error {
	switch name {
	case annotation.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	case annotation.FieldNodeID:
		m.ResetNodeID()
		return nil
	case annotation.FieldName:
		m.ResetName()
		return nil
	case annotation.FieldValue:
		m.ResetValue()
		return nil
	case annotation.FieldIsUnique:
		m.ResetIsUnique()
		return nil
	}
	return fmt.Errorf("unknown Annotation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnotationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.document != nil {
		edges = append(edges, annotation.EdgeDocument)
	}
	if m.node != nil {
		edges = append(edges, annotation.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnotationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case annotation.EdgeDocument:
		if id := m.document; id != nil {
			return []ent.Value{*id}
		}
	case annotation.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnotationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnotationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnotationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddocument {
		edges = append(edges, annotation.EdgeDocument)
	}
	if m.clearednode {
		edges = append(edges, annotation.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnotationMutation) EdgeCleared(name string) bool {
	switch name {
	case annotation.EdgeDocument:
		return m.cleareddocument
	case annotation.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnotationMutation) ClearEdge(name string) error {
	switch name {
	case annotation.EdgeDocument:
		m.ClearDocument()
		return nil
	case annotation.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown Annotation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnotationMutation) ResetEdge(name string) error {
	switch name {
	case annotation.EdgeDocument:
		m.ResetDocument()
		return nil
	case annotation.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown Annotation edge %s", name)
}

// DocumentMutation represents an operation that mutates the Document nodes in the graph.
type DocumentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	clearedFields              map[string]struct{}
	annotations                map[int]struct{}
	removedannotations         map[int]struct{}
	clearedannotations         bool
	metadata                   *uuid.UUID
	clearedmetadata            bool
	node_list                  *uuid.UUID
	clearednode_list           bool
	document_types             map[uuid.UUID]struct{}
	removeddocument_types      map[uuid.UUID]struct{}
	cleareddocument_types      bool
	edge_types                 map[uuid.UUID]struct{}
	removededge_types          map[uuid.UUID]struct{}
	clearededge_types          bool
	external_references        map[uuid.UUID]struct{}
	removedexternal_references map[uuid.UUID]struct{}
	clearedexternal_references bool
	hashes                     map[uuid.UUID]struct{}
	removedhashes              map[uuid.UUID]struct{}
	clearedhashes              bool
	identifiers                map[uuid.UUID]struct{}
	removedidentifiers         map[uuid.UUID]struct{}
	clearedidentifiers         bool
	nodes                      map[uuid.UUID]struct{}
	removednodes               map[uuid.UUID]struct{}
	clearednodes               bool
	persons                    map[uuid.UUID]struct{}
	removedpersons             map[uuid.UUID]struct{}
	clearedpersons             bool
	properties                 map[uuid.UUID]struct{}
	removedproperties          map[uuid.UUID]struct{}
	clearedproperties          bool
	purposes                   map[int]struct{}
	removedpurposes            map[int]struct{}
	clearedpurposes            bool
	source_data                map[uuid.UUID]struct{}
	removedsource_data         map[uuid.UUID]struct{}
	clearedsource_data         bool
	tools                      map[uuid.UUID]struct{}
	removedtools               map[uuid.UUID]struct{}
	clearedtools               bool
	done                       bool
	oldValue                   func(context.Context) (*Document, error)
	predicates                 []predicate.Document
}

var _ ent.Mutation = (*DocumentMutation)(nil)

// documentOption allows management of the mutation configuration using functional options.
type documentOption func(*DocumentMutation)

// newDocumentMutation creates new mutation for the Document entity.
func newDocumentMutation(c config, op Op, opts ...documentOption) *DocumentMutation {
	m := &DocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentID sets the ID field of the mutation.
func withDocumentID(id uuid.UUID) documentOption {
	return func(m *DocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Document
		)
		m.oldValue = func(ctx context.Context) (*Document, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Document.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocument sets the old Document of the mutation.
func withDocument(node *Document) documentOption {
	return func(m *DocumentMutation) {
		m.oldValue = func(context.Context) (*Document, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Document entities.
func (m *DocumentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Document.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMetadataID sets the "metadata_id" field.
func (m *DocumentMutation) SetMetadataID(u uuid.UUID) {
	m.metadata = &u
}

// MetadataID returns the value of the "metadata_id" field in the mutation.
func (m *DocumentMutation) MetadataID() (r uuid.UUID, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataID returns the old "metadata_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldMetadataID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataID: %w", err)
	}
	return oldValue.MetadataID, nil
}

// ClearMetadataID clears the value of the "metadata_id" field.
func (m *DocumentMutation) ClearMetadataID() {
	m.metadata = nil
	m.clearedFields[document.FieldMetadataID] = struct{}{}
}

// MetadataIDCleared returns if the "metadata_id" field was cleared in this mutation.
func (m *DocumentMutation) MetadataIDCleared() bool {
	_, ok := m.clearedFields[document.FieldMetadataID]
	return ok
}

// ResetMetadataID resets all changes to the "metadata_id" field.
func (m *DocumentMutation) ResetMetadataID() {
	m.metadata = nil
	delete(m.clearedFields, document.FieldMetadataID)
}

// SetNodeListID sets the "node_list_id" field.
func (m *DocumentMutation) SetNodeListID(u uuid.UUID) {
	m.node_list = &u
}

// NodeListID returns the value of the "node_list_id" field in the mutation.
func (m *DocumentMutation) NodeListID() (r uuid.UUID, exists bool) {
	v := m.node_list
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeListID returns the old "node_list_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldNodeListID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeListID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeListID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeListID: %w", err)
	}
	return oldValue.NodeListID, nil
}

// ClearNodeListID clears the value of the "node_list_id" field.
func (m *DocumentMutation) ClearNodeListID() {
	m.node_list = nil
	m.clearedFields[document.FieldNodeListID] = struct{}{}
}

// NodeListIDCleared returns if the "node_list_id" field was cleared in this mutation.
func (m *DocumentMutation) NodeListIDCleared() bool {
	_, ok := m.clearedFields[document.FieldNodeListID]
	return ok
}

// ResetNodeListID resets all changes to the "node_list_id" field.
func (m *DocumentMutation) ResetNodeListID() {
	m.node_list = nil
	delete(m.clearedFields, document.FieldNodeListID)
}

// AddAnnotationIDs adds the "annotations" edge to the Annotation entity by ids.
func (m *DocumentMutation) AddAnnotationIDs(ids ...int) {
	if m.annotations == nil {
		m.annotations = make(map[int]struct{})
	}
	for i := range ids {
		m.annotations[ids[i]] = struct{}{}
	}
}

// ClearAnnotations clears the "annotations" edge to the Annotation entity.
func (m *DocumentMutation) ClearAnnotations() {
	m.clearedannotations = true
}

// AnnotationsCleared reports if the "annotations" edge to the Annotation entity was cleared.
func (m *DocumentMutation) AnnotationsCleared() bool {
	return m.clearedannotations
}

// RemoveAnnotationIDs removes the "annotations" edge to the Annotation entity by IDs.
func (m *DocumentMutation) RemoveAnnotationIDs(ids ...int) {
	if m.removedannotations == nil {
		m.removedannotations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.annotations, ids[i])
		m.removedannotations[ids[i]] = struct{}{}
	}
}

// RemovedAnnotations returns the removed IDs of the "annotations" edge to the Annotation entity.
func (m *DocumentMutation) RemovedAnnotationsIDs() (ids []int) {
	for id := range m.removedannotations {
		ids = append(ids, id)
	}
	return
}

// AnnotationsIDs returns the "annotations" edge IDs in the mutation.
func (m *DocumentMutation) AnnotationsIDs() (ids []int) {
	for id := range m.annotations {
		ids = append(ids, id)
	}
	return
}

// ResetAnnotations resets all changes to the "annotations" edge.
func (m *DocumentMutation) ResetAnnotations() {
	m.annotations = nil
	m.clearedannotations = false
	m.removedannotations = nil
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *DocumentMutation) ClearMetadata() {
	m.clearedmetadata = true
	m.clearedFields[document.FieldMetadataID] = struct{}{}
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *DocumentMutation) MetadataCleared() bool {
	return m.MetadataIDCleared() || m.clearedmetadata
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) MetadataIDs() (ids []uuid.UUID) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *DocumentMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// ClearNodeList clears the "node_list" edge to the NodeList entity.
func (m *DocumentMutation) ClearNodeList() {
	m.clearednode_list = true
	m.clearedFields[document.FieldNodeListID] = struct{}{}
}

// NodeListCleared reports if the "node_list" edge to the NodeList entity was cleared.
func (m *DocumentMutation) NodeListCleared() bool {
	return m.NodeListIDCleared() || m.clearednode_list
}

// NodeListIDs returns the "node_list" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeListID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) NodeListIDs() (ids []uuid.UUID) {
	if id := m.node_list; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNodeList resets all changes to the "node_list" edge.
func (m *DocumentMutation) ResetNodeList() {
	m.node_list = nil
	m.clearednode_list = false
}

// AddDocumentTypeIDs adds the "document_types" edge to the DocumentType entity by ids.
func (m *DocumentMutation) AddDocumentTypeIDs(ids ...uuid.UUID) {
	if m.document_types == nil {
		m.document_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.document_types[ids[i]] = struct{}{}
	}
}

// ClearDocumentTypes clears the "document_types" edge to the DocumentType entity.
func (m *DocumentMutation) ClearDocumentTypes() {
	m.cleareddocument_types = true
}

// DocumentTypesCleared reports if the "document_types" edge to the DocumentType entity was cleared.
func (m *DocumentMutation) DocumentTypesCleared() bool {
	return m.cleareddocument_types
}

// RemoveDocumentTypeIDs removes the "document_types" edge to the DocumentType entity by IDs.
func (m *DocumentMutation) RemoveDocumentTypeIDs(ids ...uuid.UUID) {
	if m.removeddocument_types == nil {
		m.removeddocument_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.document_types, ids[i])
		m.removeddocument_types[ids[i]] = struct{}{}
	}
}

// RemovedDocumentTypes returns the removed IDs of the "document_types" edge to the DocumentType entity.
func (m *DocumentMutation) RemovedDocumentTypesIDs() (ids []uuid.UUID) {
	for id := range m.removeddocument_types {
		ids = append(ids, id)
	}
	return
}

// DocumentTypesIDs returns the "document_types" edge IDs in the mutation.
func (m *DocumentMutation) DocumentTypesIDs() (ids []uuid.UUID) {
	for id := range m.document_types {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentTypes resets all changes to the "document_types" edge.
func (m *DocumentMutation) ResetDocumentTypes() {
	m.document_types = nil
	m.cleareddocument_types = false
	m.removeddocument_types = nil
}

// AddEdgeTypeIDs adds the "edge_types" edge to the EdgeType entity by ids.
func (m *DocumentMutation) AddEdgeTypeIDs(ids ...uuid.UUID) {
	if m.edge_types == nil {
		m.edge_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.edge_types[ids[i]] = struct{}{}
	}
}

// ClearEdgeTypes clears the "edge_types" edge to the EdgeType entity.
func (m *DocumentMutation) ClearEdgeTypes() {
	m.clearededge_types = true
}

// EdgeTypesCleared reports if the "edge_types" edge to the EdgeType entity was cleared.
func (m *DocumentMutation) EdgeTypesCleared() bool {
	return m.clearededge_types
}

// RemoveEdgeTypeIDs removes the "edge_types" edge to the EdgeType entity by IDs.
func (m *DocumentMutation) RemoveEdgeTypeIDs(ids ...uuid.UUID) {
	if m.removededge_types == nil {
		m.removededge_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.edge_types, ids[i])
		m.removededge_types[ids[i]] = struct{}{}
	}
}

// RemovedEdgeTypes returns the removed IDs of the "edge_types" edge to the EdgeType entity.
func (m *DocumentMutation) RemovedEdgeTypesIDs() (ids []uuid.UUID) {
	for id := range m.removededge_types {
		ids = append(ids, id)
	}
	return
}

// EdgeTypesIDs returns the "edge_types" edge IDs in the mutation.
func (m *DocumentMutation) EdgeTypesIDs() (ids []uuid.UUID) {
	for id := range m.edge_types {
		ids = append(ids, id)
	}
	return
}

// ResetEdgeTypes resets all changes to the "edge_types" edge.
func (m *DocumentMutation) ResetEdgeTypes() {
	m.edge_types = nil
	m.clearededge_types = false
	m.removededge_types = nil
}

// AddExternalReferenceIDs adds the "external_references" edge to the ExternalReference entity by ids.
func (m *DocumentMutation) AddExternalReferenceIDs(ids ...uuid.UUID) {
	if m.external_references == nil {
		m.external_references = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.external_references[ids[i]] = struct{}{}
	}
}

// ClearExternalReferences clears the "external_references" edge to the ExternalReference entity.
func (m *DocumentMutation) ClearExternalReferences() {
	m.clearedexternal_references = true
}

// ExternalReferencesCleared reports if the "external_references" edge to the ExternalReference entity was cleared.
func (m *DocumentMutation) ExternalReferencesCleared() bool {
	return m.clearedexternal_references
}

// RemoveExternalReferenceIDs removes the "external_references" edge to the ExternalReference entity by IDs.
func (m *DocumentMutation) RemoveExternalReferenceIDs(ids ...uuid.UUID) {
	if m.removedexternal_references == nil {
		m.removedexternal_references = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.external_references, ids[i])
		m.removedexternal_references[ids[i]] = struct{}{}
	}
}

// RemovedExternalReferences returns the removed IDs of the "external_references" edge to the ExternalReference entity.
func (m *DocumentMutation) RemovedExternalReferencesIDs() (ids []uuid.UUID) {
	for id := range m.removedexternal_references {
		ids = append(ids, id)
	}
	return
}

// ExternalReferencesIDs returns the "external_references" edge IDs in the mutation.
func (m *DocumentMutation) ExternalReferencesIDs() (ids []uuid.UUID) {
	for id := range m.external_references {
		ids = append(ids, id)
	}
	return
}

// ResetExternalReferences resets all changes to the "external_references" edge.
func (m *DocumentMutation) ResetExternalReferences() {
	m.external_references = nil
	m.clearedexternal_references = false
	m.removedexternal_references = nil
}

// AddHashIDs adds the "hashes" edge to the HashesEntry entity by ids.
func (m *DocumentMutation) AddHashIDs(ids ...uuid.UUID) {
	if m.hashes == nil {
		m.hashes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hashes[ids[i]] = struct{}{}
	}
}

// ClearHashes clears the "hashes" edge to the HashesEntry entity.
func (m *DocumentMutation) ClearHashes() {
	m.clearedhashes = true
}

// HashesCleared reports if the "hashes" edge to the HashesEntry entity was cleared.
func (m *DocumentMutation) HashesCleared() bool {
	return m.clearedhashes
}

// RemoveHashIDs removes the "hashes" edge to the HashesEntry entity by IDs.
func (m *DocumentMutation) RemoveHashIDs(ids ...uuid.UUID) {
	if m.removedhashes == nil {
		m.removedhashes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hashes, ids[i])
		m.removedhashes[ids[i]] = struct{}{}
	}
}

// RemovedHashes returns the removed IDs of the "hashes" edge to the HashesEntry entity.
func (m *DocumentMutation) RemovedHashesIDs() (ids []uuid.UUID) {
	for id := range m.removedhashes {
		ids = append(ids, id)
	}
	return
}

// HashesIDs returns the "hashes" edge IDs in the mutation.
func (m *DocumentMutation) HashesIDs() (ids []uuid.UUID) {
	for id := range m.hashes {
		ids = append(ids, id)
	}
	return
}

// ResetHashes resets all changes to the "hashes" edge.
func (m *DocumentMutation) ResetHashes() {
	m.hashes = nil
	m.clearedhashes = false
	m.removedhashes = nil
}

// AddIdentifierIDs adds the "identifiers" edge to the IdentifiersEntry entity by ids.
func (m *DocumentMutation) AddIdentifierIDs(ids ...uuid.UUID) {
	if m.identifiers == nil {
		m.identifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.identifiers[ids[i]] = struct{}{}
	}
}

// ClearIdentifiers clears the "identifiers" edge to the IdentifiersEntry entity.
func (m *DocumentMutation) ClearIdentifiers() {
	m.clearedidentifiers = true
}

// IdentifiersCleared reports if the "identifiers" edge to the IdentifiersEntry entity was cleared.
func (m *DocumentMutation) IdentifiersCleared() bool {
	return m.clearedidentifiers
}

// RemoveIdentifierIDs removes the "identifiers" edge to the IdentifiersEntry entity by IDs.
func (m *DocumentMutation) RemoveIdentifierIDs(ids ...uuid.UUID) {
	if m.removedidentifiers == nil {
		m.removedidentifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.identifiers, ids[i])
		m.removedidentifiers[ids[i]] = struct{}{}
	}
}

// RemovedIdentifiers returns the removed IDs of the "identifiers" edge to the IdentifiersEntry entity.
func (m *DocumentMutation) RemovedIdentifiersIDs() (ids []uuid.UUID) {
	for id := range m.removedidentifiers {
		ids = append(ids, id)
	}
	return
}

// IdentifiersIDs returns the "identifiers" edge IDs in the mutation.
func (m *DocumentMutation) IdentifiersIDs() (ids []uuid.UUID) {
	for id := range m.identifiers {
		ids = append(ids, id)
	}
	return
}

// ResetIdentifiers resets all changes to the "identifiers" edge.
func (m *DocumentMutation) ResetIdentifiers() {
	m.identifiers = nil
	m.clearedidentifiers = false
	m.removedidentifiers = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *DocumentMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *DocumentMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *DocumentMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *DocumentMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *DocumentMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *DocumentMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *DocumentMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddPersonIDs adds the "persons" edge to the Person entity by ids.
func (m *DocumentMutation) AddPersonIDs(ids ...uuid.UUID) {
	if m.persons == nil {
		m.persons = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.persons[ids[i]] = struct{}{}
	}
}

// ClearPersons clears the "persons" edge to the Person entity.
func (m *DocumentMutation) ClearPersons() {
	m.clearedpersons = true
}

// PersonsCleared reports if the "persons" edge to the Person entity was cleared.
func (m *DocumentMutation) PersonsCleared() bool {
	return m.clearedpersons
}

// RemovePersonIDs removes the "persons" edge to the Person entity by IDs.
func (m *DocumentMutation) RemovePersonIDs(ids ...uuid.UUID) {
	if m.removedpersons == nil {
		m.removedpersons = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.persons, ids[i])
		m.removedpersons[ids[i]] = struct{}{}
	}
}

// RemovedPersons returns the removed IDs of the "persons" edge to the Person entity.
func (m *DocumentMutation) RemovedPersonsIDs() (ids []uuid.UUID) {
	for id := range m.removedpersons {
		ids = append(ids, id)
	}
	return
}

// PersonsIDs returns the "persons" edge IDs in the mutation.
func (m *DocumentMutation) PersonsIDs() (ids []uuid.UUID) {
	for id := range m.persons {
		ids = append(ids, id)
	}
	return
}

// ResetPersons resets all changes to the "persons" edge.
func (m *DocumentMutation) ResetPersons() {
	m.persons = nil
	m.clearedpersons = false
	m.removedpersons = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *DocumentMutation) AddPropertyIDs(ids ...uuid.UUID) {
	if m.properties == nil {
		m.properties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *DocumentMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *DocumentMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *DocumentMutation) RemovePropertyIDs(ids ...uuid.UUID) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *DocumentMutation) RemovedPropertiesIDs() (ids []uuid.UUID) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *DocumentMutation) PropertiesIDs() (ids []uuid.UUID) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *DocumentMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddPurposeIDs adds the "purposes" edge to the Purpose entity by ids.
func (m *DocumentMutation) AddPurposeIDs(ids ...int) {
	if m.purposes == nil {
		m.purposes = make(map[int]struct{})
	}
	for i := range ids {
		m.purposes[ids[i]] = struct{}{}
	}
}

// ClearPurposes clears the "purposes" edge to the Purpose entity.
func (m *DocumentMutation) ClearPurposes() {
	m.clearedpurposes = true
}

// PurposesCleared reports if the "purposes" edge to the Purpose entity was cleared.
func (m *DocumentMutation) PurposesCleared() bool {
	return m.clearedpurposes
}

// RemovePurposeIDs removes the "purposes" edge to the Purpose entity by IDs.
func (m *DocumentMutation) RemovePurposeIDs(ids ...int) {
	if m.removedpurposes == nil {
		m.removedpurposes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.purposes, ids[i])
		m.removedpurposes[ids[i]] = struct{}{}
	}
}

// RemovedPurposes returns the removed IDs of the "purposes" edge to the Purpose entity.
func (m *DocumentMutation) RemovedPurposesIDs() (ids []int) {
	for id := range m.removedpurposes {
		ids = append(ids, id)
	}
	return
}

// PurposesIDs returns the "purposes" edge IDs in the mutation.
func (m *DocumentMutation) PurposesIDs() (ids []int) {
	for id := range m.purposes {
		ids = append(ids, id)
	}
	return
}

// ResetPurposes resets all changes to the "purposes" edge.
func (m *DocumentMutation) ResetPurposes() {
	m.purposes = nil
	m.clearedpurposes = false
	m.removedpurposes = nil
}

// AddSourceDatumIDs adds the "source_data" edge to the SourceData entity by ids.
func (m *DocumentMutation) AddSourceDatumIDs(ids ...uuid.UUID) {
	if m.source_data == nil {
		m.source_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.source_data[ids[i]] = struct{}{}
	}
}

// ClearSourceData clears the "source_data" edge to the SourceData entity.
func (m *DocumentMutation) ClearSourceData() {
	m.clearedsource_data = true
}

// SourceDataCleared reports if the "source_data" edge to the SourceData entity was cleared.
func (m *DocumentMutation) SourceDataCleared() bool {
	return m.clearedsource_data
}

// RemoveSourceDatumIDs removes the "source_data" edge to the SourceData entity by IDs.
func (m *DocumentMutation) RemoveSourceDatumIDs(ids ...uuid.UUID) {
	if m.removedsource_data == nil {
		m.removedsource_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.source_data, ids[i])
		m.removedsource_data[ids[i]] = struct{}{}
	}
}

// RemovedSourceData returns the removed IDs of the "source_data" edge to the SourceData entity.
func (m *DocumentMutation) RemovedSourceDataIDs() (ids []uuid.UUID) {
	for id := range m.removedsource_data {
		ids = append(ids, id)
	}
	return
}

// SourceDataIDs returns the "source_data" edge IDs in the mutation.
func (m *DocumentMutation) SourceDataIDs() (ids []uuid.UUID) {
	for id := range m.source_data {
		ids = append(ids, id)
	}
	return
}

// ResetSourceData resets all changes to the "source_data" edge.
func (m *DocumentMutation) ResetSourceData() {
	m.source_data = nil
	m.clearedsource_data = false
	m.removedsource_data = nil
}

// AddToolIDs adds the "tools" edge to the Tool entity by ids.
func (m *DocumentMutation) AddToolIDs(ids ...uuid.UUID) {
	if m.tools == nil {
		m.tools = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tools[ids[i]] = struct{}{}
	}
}

// ClearTools clears the "tools" edge to the Tool entity.
func (m *DocumentMutation) ClearTools() {
	m.clearedtools = true
}

// ToolsCleared reports if the "tools" edge to the Tool entity was cleared.
func (m *DocumentMutation) ToolsCleared() bool {
	return m.clearedtools
}

// RemoveToolIDs removes the "tools" edge to the Tool entity by IDs.
func (m *DocumentMutation) RemoveToolIDs(ids ...uuid.UUID) {
	if m.removedtools == nil {
		m.removedtools = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tools, ids[i])
		m.removedtools[ids[i]] = struct{}{}
	}
}

// RemovedTools returns the removed IDs of the "tools" edge to the Tool entity.
func (m *DocumentMutation) RemovedToolsIDs() (ids []uuid.UUID) {
	for id := range m.removedtools {
		ids = append(ids, id)
	}
	return
}

// ToolsIDs returns the "tools" edge IDs in the mutation.
func (m *DocumentMutation) ToolsIDs() (ids []uuid.UUID) {
	for id := range m.tools {
		ids = append(ids, id)
	}
	return
}

// ResetTools resets all changes to the "tools" edge.
func (m *DocumentMutation) ResetTools() {
	m.tools = nil
	m.clearedtools = false
	m.removedtools = nil
}

// Where appends a list predicates to the DocumentMutation builder.
func (m *DocumentMutation) Where(ps ...predicate.Document) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Document, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Document).
func (m *DocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.metadata != nil {
		fields = append(fields, document.FieldMetadataID)
	}
	if m.node_list != nil {
		fields = append(fields, document.FieldNodeListID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case document.FieldMetadataID:
		return m.MetadataID()
	case document.FieldNodeListID:
		return m.NodeListID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case document.FieldMetadataID:
		return m.OldMetadataID(ctx)
	case document.FieldNodeListID:
		return m.OldNodeListID(ctx)
	}
	return nil, fmt.Errorf("unknown Document field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case document.FieldMetadataID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataID(v)
		return nil
	case document.FieldNodeListID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeListID(v)
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Document numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(document.FieldMetadataID) {
		fields = append(fields, document.FieldMetadataID)
	}
	if m.FieldCleared(document.FieldNodeListID) {
		fields = append(fields, document.FieldNodeListID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentMutation) ClearField(name string) error {
	switch name {
	case document.FieldMetadataID:
		m.ClearMetadataID()
		return nil
	case document.FieldNodeListID:
		m.ClearNodeListID()
		return nil
	}
	return fmt.Errorf("unknown Document nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentMutation) ResetField(name string) error {
	switch name {
	case document.FieldMetadataID:
		m.ResetMetadataID()
		return nil
	case document.FieldNodeListID:
		m.ResetNodeListID()
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.annotations != nil {
		edges = append(edges, document.EdgeAnnotations)
	}
	if m.metadata != nil {
		edges = append(edges, document.EdgeMetadata)
	}
	if m.node_list != nil {
		edges = append(edges, document.EdgeNodeList)
	}
	if m.document_types != nil {
		edges = append(edges, document.EdgeDocumentTypes)
	}
	if m.edge_types != nil {
		edges = append(edges, document.EdgeEdgeTypes)
	}
	if m.external_references != nil {
		edges = append(edges, document.EdgeExternalReferences)
	}
	if m.hashes != nil {
		edges = append(edges, document.EdgeHashes)
	}
	if m.identifiers != nil {
		edges = append(edges, document.EdgeIdentifiers)
	}
	if m.nodes != nil {
		edges = append(edges, document.EdgeNodes)
	}
	if m.persons != nil {
		edges = append(edges, document.EdgePersons)
	}
	if m.properties != nil {
		edges = append(edges, document.EdgeProperties)
	}
	if m.purposes != nil {
		edges = append(edges, document.EdgePurposes)
	}
	if m.source_data != nil {
		edges = append(edges, document.EdgeSourceData)
	}
	if m.tools != nil {
		edges = append(edges, document.EdgeTools)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.annotations))
		for id := range m.annotations {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeNodeList:
		if id := m.node_list; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeDocumentTypes:
		ids := make([]ent.Value, 0, len(m.document_types))
		for id := range m.document_types {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeEdgeTypes:
		ids := make([]ent.Value, 0, len(m.edge_types))
		for id := range m.edge_types {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeExternalReferences:
		ids := make([]ent.Value, 0, len(m.external_references))
		for id := range m.external_references {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeHashes:
		ids := make([]ent.Value, 0, len(m.hashes))
		for id := range m.hashes {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.identifiers))
		for id := range m.identifiers {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case document.EdgePersons:
		ids := make([]ent.Value, 0, len(m.persons))
		for id := range m.persons {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case document.EdgePurposes:
		ids := make([]ent.Value, 0, len(m.purposes))
		for id := range m.purposes {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeSourceData:
		ids := make([]ent.Value, 0, len(m.source_data))
		for id := range m.source_data {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeTools:
		ids := make([]ent.Value, 0, len(m.tools))
		for id := range m.tools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedannotations != nil {
		edges = append(edges, document.EdgeAnnotations)
	}
	if m.removeddocument_types != nil {
		edges = append(edges, document.EdgeDocumentTypes)
	}
	if m.removededge_types != nil {
		edges = append(edges, document.EdgeEdgeTypes)
	}
	if m.removedexternal_references != nil {
		edges = append(edges, document.EdgeExternalReferences)
	}
	if m.removedhashes != nil {
		edges = append(edges, document.EdgeHashes)
	}
	if m.removedidentifiers != nil {
		edges = append(edges, document.EdgeIdentifiers)
	}
	if m.removednodes != nil {
		edges = append(edges, document.EdgeNodes)
	}
	if m.removedpersons != nil {
		edges = append(edges, document.EdgePersons)
	}
	if m.removedproperties != nil {
		edges = append(edges, document.EdgeProperties)
	}
	if m.removedpurposes != nil {
		edges = append(edges, document.EdgePurposes)
	}
	if m.removedsource_data != nil {
		edges = append(edges, document.EdgeSourceData)
	}
	if m.removedtools != nil {
		edges = append(edges, document.EdgeTools)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.removedannotations))
		for id := range m.removedannotations {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeDocumentTypes:
		ids := make([]ent.Value, 0, len(m.removeddocument_types))
		for id := range m.removeddocument_types {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeEdgeTypes:
		ids := make([]ent.Value, 0, len(m.removededge_types))
		for id := range m.removededge_types {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeExternalReferences:
		ids := make([]ent.Value, 0, len(m.removedexternal_references))
		for id := range m.removedexternal_references {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeHashes:
		ids := make([]ent.Value, 0, len(m.removedhashes))
		for id := range m.removedhashes {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.removedidentifiers))
		for id := range m.removedidentifiers {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case document.EdgePersons:
		ids := make([]ent.Value, 0, len(m.removedpersons))
		for id := range m.removedpersons {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case document.EdgePurposes:
		ids := make([]ent.Value, 0, len(m.removedpurposes))
		for id := range m.removedpurposes {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeSourceData:
		ids := make([]ent.Value, 0, len(m.removedsource_data))
		for id := range m.removedsource_data {
			ids = append(ids, id)
		}
		return ids
	case document.EdgeTools:
		ids := make([]ent.Value, 0, len(m.removedtools))
		for id := range m.removedtools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedannotations {
		edges = append(edges, document.EdgeAnnotations)
	}
	if m.clearedmetadata {
		edges = append(edges, document.EdgeMetadata)
	}
	if m.clearednode_list {
		edges = append(edges, document.EdgeNodeList)
	}
	if m.cleareddocument_types {
		edges = append(edges, document.EdgeDocumentTypes)
	}
	if m.clearededge_types {
		edges = append(edges, document.EdgeEdgeTypes)
	}
	if m.clearedexternal_references {
		edges = append(edges, document.EdgeExternalReferences)
	}
	if m.clearedhashes {
		edges = append(edges, document.EdgeHashes)
	}
	if m.clearedidentifiers {
		edges = append(edges, document.EdgeIdentifiers)
	}
	if m.clearednodes {
		edges = append(edges, document.EdgeNodes)
	}
	if m.clearedpersons {
		edges = append(edges, document.EdgePersons)
	}
	if m.clearedproperties {
		edges = append(edges, document.EdgeProperties)
	}
	if m.clearedpurposes {
		edges = append(edges, document.EdgePurposes)
	}
	if m.clearedsource_data {
		edges = append(edges, document.EdgeSourceData)
	}
	if m.clearedtools {
		edges = append(edges, document.EdgeTools)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case document.EdgeAnnotations:
		return m.clearedannotations
	case document.EdgeMetadata:
		return m.clearedmetadata
	case document.EdgeNodeList:
		return m.clearednode_list
	case document.EdgeDocumentTypes:
		return m.cleareddocument_types
	case document.EdgeEdgeTypes:
		return m.clearededge_types
	case document.EdgeExternalReferences:
		return m.clearedexternal_references
	case document.EdgeHashes:
		return m.clearedhashes
	case document.EdgeIdentifiers:
		return m.clearedidentifiers
	case document.EdgeNodes:
		return m.clearednodes
	case document.EdgePersons:
		return m.clearedpersons
	case document.EdgeProperties:
		return m.clearedproperties
	case document.EdgePurposes:
		return m.clearedpurposes
	case document.EdgeSourceData:
		return m.clearedsource_data
	case document.EdgeTools:
		return m.clearedtools
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentMutation) ClearEdge(name string) error {
	switch name {
	case document.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case document.EdgeNodeList:
		m.ClearNodeList()
		return nil
	}
	return fmt.Errorf("unknown Document unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentMutation) ResetEdge(name string) error {
	switch name {
	case document.EdgeAnnotations:
		m.ResetAnnotations()
		return nil
	case document.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case document.EdgeNodeList:
		m.ResetNodeList()
		return nil
	case document.EdgeDocumentTypes:
		m.ResetDocumentTypes()
		return nil
	case document.EdgeEdgeTypes:
		m.ResetEdgeTypes()
		return nil
	case document.EdgeExternalReferences:
		m.ResetExternalReferences()
		return nil
	case document.EdgeHashes:
		m.ResetHashes()
		return nil
	case document.EdgeIdentifiers:
		m.ResetIdentifiers()
		return nil
	case document.EdgeNodes:
		m.ResetNodes()
		return nil
	case document.EdgePersons:
		m.ResetPersons()
		return nil
	case document.EdgeProperties:
		m.ResetProperties()
		return nil
	case document.EdgePurposes:
		m.ResetPurposes()
		return nil
	case document.EdgeSourceData:
		m.ResetSourceData()
		return nil
	case document.EdgeTools:
		m.ResetTools()
		return nil
	}
	return fmt.Errorf("unknown Document edge %s", name)
}

// DocumentTypeMutation represents an operation that mutates the DocumentType nodes in the graph.
type DocumentTypeMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	proto_message    **sbom.DocumentType
	_type            *documenttype.Type
	name             *string
	description      *string
	clearedFields    map[string]struct{}
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	metadata         map[uuid.UUID]struct{}
	removedmetadata  map[uuid.UUID]struct{}
	clearedmetadata  bool
	done             bool
	oldValue         func(context.Context) (*DocumentType, error)
	predicates       []predicate.DocumentType
}

var _ ent.Mutation = (*DocumentTypeMutation)(nil)

// documenttypeOption allows management of the mutation configuration using functional options.
type documenttypeOption func(*DocumentTypeMutation)

// newDocumentTypeMutation creates new mutation for the DocumentType entity.
func newDocumentTypeMutation(c config, op Op, opts ...documenttypeOption) *DocumentTypeMutation {
	m := &DocumentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentTypeID sets the ID field of the mutation.
func withDocumentTypeID(id uuid.UUID) documenttypeOption {
	return func(m *DocumentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentType
		)
		m.oldValue = func(ctx context.Context) (*DocumentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentType sets the old DocumentType of the mutation.
func withDocumentType(node *DocumentType) documenttypeOption {
	return func(m *DocumentTypeMutation) {
		m.oldValue = func(context.Context) (*DocumentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentType entities.
func (m *DocumentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *DocumentTypeMutation) SetProtoMessage(st *sbom.DocumentType) {
	m.proto_message = &st
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *DocumentTypeMutation) ProtoMessage() (r *sbom.DocumentType, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldProtoMessage(ctx context.Context) (v *sbom.DocumentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *DocumentTypeMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetType sets the "type" field.
func (m *DocumentTypeMutation) SetType(d documenttype.Type) {
	m._type = &d
}

// GetType returns the value of the "type" field in the mutation.
func (m *DocumentTypeMutation) GetType() (r documenttype.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldType(ctx context.Context) (v *documenttype.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *DocumentTypeMutation) ClearType() {
	m._type = nil
	m.clearedFields[documenttype.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *DocumentTypeMutation) TypeCleared() bool {
	_, ok := m.clearedFields[documenttype.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *DocumentTypeMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, documenttype.FieldType)
}

// SetName sets the "name" field.
func (m *DocumentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocumentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DocumentTypeMutation) ClearName() {
	m.name = nil
	m.clearedFields[documenttype.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DocumentTypeMutation) NameCleared() bool {
	_, ok := m.clearedFields[documenttype.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DocumentTypeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, documenttype.FieldName)
}

// SetDescription sets the "description" field.
func (m *DocumentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DocumentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DocumentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[documenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DocumentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[documenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DocumentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, documenttype.FieldDescription)
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *DocumentTypeMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *DocumentTypeMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *DocumentTypeMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *DocumentTypeMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *DocumentTypeMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *DocumentTypeMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *DocumentTypeMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *DocumentTypeMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *DocumentTypeMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *DocumentTypeMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *DocumentTypeMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *DocumentTypeMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *DocumentTypeMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *DocumentTypeMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// Where appends a list predicates to the DocumentTypeMutation builder.
func (m *DocumentTypeMutation) Where(ps ...predicate.DocumentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentType).
func (m *DocumentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.proto_message != nil {
		fields = append(fields, documenttype.FieldProtoMessage)
	}
	if m._type != nil {
		fields = append(fields, documenttype.FieldType)
	}
	if m.name != nil {
		fields = append(fields, documenttype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, documenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documenttype.FieldProtoMessage:
		return m.ProtoMessage()
	case documenttype.FieldType:
		return m.GetType()
	case documenttype.FieldName:
		return m.Name()
	case documenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documenttype.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case documenttype.FieldType:
		return m.OldType(ctx)
	case documenttype.FieldName:
		return m.OldName(ctx)
	case documenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documenttype.FieldProtoMessage:
		v, ok := value.(*sbom.DocumentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case documenttype.FieldType:
		v, ok := value.(documenttype.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case documenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case documenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documenttype.FieldType) {
		fields = append(fields, documenttype.FieldType)
	}
	if m.FieldCleared(documenttype.FieldName) {
		fields = append(fields, documenttype.FieldName)
	}
	if m.FieldCleared(documenttype.FieldDescription) {
		fields = append(fields, documenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentTypeMutation) ClearField(name string) error {
	switch name {
	case documenttype.FieldType:
		m.ClearType()
		return nil
	case documenttype.FieldName:
		m.ClearName()
		return nil
	case documenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DocumentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentTypeMutation) ResetField(name string) error {
	switch name {
	case documenttype.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case documenttype.FieldType:
		m.ResetType()
		return nil
	case documenttype.FieldName:
		m.ResetName()
		return nil
	case documenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DocumentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.documents != nil {
		edges = append(edges, documenttype.EdgeDocuments)
	}
	if m.metadata != nil {
		edges = append(edges, documenttype.EdgeMetadata)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documenttype.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case documenttype.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddocuments != nil {
		edges = append(edges, documenttype.EdgeDocuments)
	}
	if m.removedmetadata != nil {
		edges = append(edges, documenttype.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case documenttype.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case documenttype.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddocuments {
		edges = append(edges, documenttype.EdgeDocuments)
	}
	if m.clearedmetadata {
		edges = append(edges, documenttype.EdgeMetadata)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case documenttype.EdgeDocuments:
		return m.cleareddocuments
	case documenttype.EdgeMetadata:
		return m.clearedmetadata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentTypeMutation) ResetEdge(name string) error {
	switch name {
	case documenttype.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case documenttype.EdgeMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown DocumentType edge %s", name)
}

// EdgeTypeMutation represents an operation that mutates the EdgeType nodes in the graph.
type EdgeTypeMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	proto_message     **sbom.Edge
	_type             *edgetype.Type
	clearedFields     map[string]struct{}
	from              *uuid.UUID
	clearedfrom       bool
	to                *uuid.UUID
	clearedto         bool
	documents         map[uuid.UUID]struct{}
	removeddocuments  map[uuid.UUID]struct{}
	cleareddocuments  bool
	node_lists        map[uuid.UUID]struct{}
	removednode_lists map[uuid.UUID]struct{}
	clearednode_lists bool
	done              bool
	oldValue          func(context.Context) (*EdgeType, error)
	predicates        []predicate.EdgeType
}

var _ ent.Mutation = (*EdgeTypeMutation)(nil)

// edgetypeOption allows management of the mutation configuration using functional options.
type edgetypeOption func(*EdgeTypeMutation)

// newEdgeTypeMutation creates new mutation for the EdgeType entity.
func newEdgeTypeMutation(c config, op Op, opts ...edgetypeOption) *EdgeTypeMutation {
	m := &EdgeTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEdgeType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEdgeTypeID sets the ID field of the mutation.
func withEdgeTypeID(id uuid.UUID) edgetypeOption {
	return func(m *EdgeTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EdgeType
		)
		m.oldValue = func(ctx context.Context) (*EdgeType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EdgeType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEdgeType sets the old EdgeType of the mutation.
func withEdgeType(node *EdgeType) edgetypeOption {
	return func(m *EdgeTypeMutation) {
		m.oldValue = func(context.Context) (*EdgeType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EdgeTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EdgeTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EdgeType entities.
func (m *EdgeTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EdgeTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EdgeTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EdgeType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *EdgeTypeMutation) SetProtoMessage(s *sbom.Edge) {
	m.proto_message = &s
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *EdgeTypeMutation) ProtoMessage() (r *sbom.Edge, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the EdgeType entity.
// If the EdgeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EdgeTypeMutation) OldProtoMessage(ctx context.Context) (v *sbom.Edge, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *EdgeTypeMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetType sets the "type" field.
func (m *EdgeTypeMutation) SetType(e edgetype.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *EdgeTypeMutation) GetType() (r edgetype.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the EdgeType entity.
// If the EdgeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EdgeTypeMutation) OldType(ctx context.Context) (v edgetype.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EdgeTypeMutation) ResetType() {
	m._type = nil
}

// SetNodeID sets the "node_id" field.
func (m *EdgeTypeMutation) SetNodeID(u uuid.UUID) {
	m.from = &u
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *EdgeTypeMutation) NodeID() (r uuid.UUID, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the EdgeType entity.
// If the EdgeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EdgeTypeMutation) OldNodeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *EdgeTypeMutation) ResetNodeID() {
	m.from = nil
}

// SetToNodeID sets the "to_node_id" field.
func (m *EdgeTypeMutation) SetToNodeID(u uuid.UUID) {
	m.to = &u
}

// ToNodeID returns the value of the "to_node_id" field in the mutation.
func (m *EdgeTypeMutation) ToNodeID() (r uuid.UUID, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldToNodeID returns the old "to_node_id" field's value of the EdgeType entity.
// If the EdgeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EdgeTypeMutation) OldToNodeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToNodeID: %w", err)
	}
	return oldValue.ToNodeID, nil
}

// ResetToNodeID resets all changes to the "to_node_id" field.
func (m *EdgeTypeMutation) ResetToNodeID() {
	m.to = nil
}

// SetFromID sets the "from" edge to the Node entity by id.
func (m *EdgeTypeMutation) SetFromID(id uuid.UUID) {
	m.from = &id
}

// ClearFrom clears the "from" edge to the Node entity.
func (m *EdgeTypeMutation) ClearFrom() {
	m.clearedfrom = true
	m.clearedFields[edgetype.FieldNodeID] = struct{}{}
}

// FromCleared reports if the "from" edge to the Node entity was cleared.
func (m *EdgeTypeMutation) FromCleared() bool {
	return m.clearedfrom
}

// FromID returns the "from" edge ID in the mutation.
func (m *EdgeTypeMutation) FromID() (id uuid.UUID, exists bool) {
	if m.from != nil {
		return *m.from, true
	}
	return
}

// FromIDs returns the "from" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromID instead. It exists only for internal usage by the builders.
func (m *EdgeTypeMutation) FromIDs() (ids []uuid.UUID) {
	if id := m.from; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrom resets all changes to the "from" edge.
func (m *EdgeTypeMutation) ResetFrom() {
	m.from = nil
	m.clearedfrom = false
}

// SetToID sets the "to" edge to the Node entity by id.
func (m *EdgeTypeMutation) SetToID(id uuid.UUID) {
	m.to = &id
}

// ClearTo clears the "to" edge to the Node entity.
func (m *EdgeTypeMutation) ClearTo() {
	m.clearedto = true
	m.clearedFields[edgetype.FieldToNodeID] = struct{}{}
}

// ToCleared reports if the "to" edge to the Node entity was cleared.
func (m *EdgeTypeMutation) ToCleared() bool {
	return m.clearedto
}

// ToID returns the "to" edge ID in the mutation.
func (m *EdgeTypeMutation) ToID() (id uuid.UUID, exists bool) {
	if m.to != nil {
		return *m.to, true
	}
	return
}

// ToIDs returns the "to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToID instead. It exists only for internal usage by the builders.
func (m *EdgeTypeMutation) ToIDs() (ids []uuid.UUID) {
	if id := m.to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTo resets all changes to the "to" edge.
func (m *EdgeTypeMutation) ResetTo() {
	m.to = nil
	m.clearedto = false
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *EdgeTypeMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *EdgeTypeMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *EdgeTypeMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *EdgeTypeMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *EdgeTypeMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *EdgeTypeMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *EdgeTypeMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddNodeListIDs adds the "node_lists" edge to the NodeList entity by ids.
func (m *EdgeTypeMutation) AddNodeListIDs(ids ...uuid.UUID) {
	if m.node_lists == nil {
		m.node_lists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.node_lists[ids[i]] = struct{}{}
	}
}

// ClearNodeLists clears the "node_lists" edge to the NodeList entity.
func (m *EdgeTypeMutation) ClearNodeLists() {
	m.clearednode_lists = true
}

// NodeListsCleared reports if the "node_lists" edge to the NodeList entity was cleared.
func (m *EdgeTypeMutation) NodeListsCleared() bool {
	return m.clearednode_lists
}

// RemoveNodeListIDs removes the "node_lists" edge to the NodeList entity by IDs.
func (m *EdgeTypeMutation) RemoveNodeListIDs(ids ...uuid.UUID) {
	if m.removednode_lists == nil {
		m.removednode_lists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.node_lists, ids[i])
		m.removednode_lists[ids[i]] = struct{}{}
	}
}

// RemovedNodeLists returns the removed IDs of the "node_lists" edge to the NodeList entity.
func (m *EdgeTypeMutation) RemovedNodeListsIDs() (ids []uuid.UUID) {
	for id := range m.removednode_lists {
		ids = append(ids, id)
	}
	return
}

// NodeListsIDs returns the "node_lists" edge IDs in the mutation.
func (m *EdgeTypeMutation) NodeListsIDs() (ids []uuid.UUID) {
	for id := range m.node_lists {
		ids = append(ids, id)
	}
	return
}

// ResetNodeLists resets all changes to the "node_lists" edge.
func (m *EdgeTypeMutation) ResetNodeLists() {
	m.node_lists = nil
	m.clearednode_lists = false
	m.removednode_lists = nil
}

// Where appends a list predicates to the EdgeTypeMutation builder.
func (m *EdgeTypeMutation) Where(ps ...predicate.EdgeType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EdgeTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EdgeTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EdgeType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EdgeTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EdgeTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EdgeType).
func (m *EdgeTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EdgeTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.proto_message != nil {
		fields = append(fields, edgetype.FieldProtoMessage)
	}
	if m._type != nil {
		fields = append(fields, edgetype.FieldType)
	}
	if m.from != nil {
		fields = append(fields, edgetype.FieldNodeID)
	}
	if m.to != nil {
		fields = append(fields, edgetype.FieldToNodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EdgeTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case edgetype.FieldProtoMessage:
		return m.ProtoMessage()
	case edgetype.FieldType:
		return m.GetType()
	case edgetype.FieldNodeID:
		return m.NodeID()
	case edgetype.FieldToNodeID:
		return m.ToNodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EdgeTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case edgetype.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case edgetype.FieldType:
		return m.OldType(ctx)
	case edgetype.FieldNodeID:
		return m.OldNodeID(ctx)
	case edgetype.FieldToNodeID:
		return m.OldToNodeID(ctx)
	}
	return nil, fmt.Errorf("unknown EdgeType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EdgeTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case edgetype.FieldProtoMessage:
		v, ok := value.(*sbom.Edge)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case edgetype.FieldType:
		v, ok := value.(edgetype.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case edgetype.FieldNodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case edgetype.FieldToNodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToNodeID(v)
		return nil
	}
	return fmt.Errorf("unknown EdgeType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EdgeTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EdgeTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EdgeTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EdgeType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EdgeTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EdgeTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EdgeTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EdgeType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EdgeTypeMutation) ResetField(name string) error {
	switch name {
	case edgetype.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case edgetype.FieldType:
		m.ResetType()
		return nil
	case edgetype.FieldNodeID:
		m.ResetNodeID()
		return nil
	case edgetype.FieldToNodeID:
		m.ResetToNodeID()
		return nil
	}
	return fmt.Errorf("unknown EdgeType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EdgeTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.from != nil {
		edges = append(edges, edgetype.EdgeFrom)
	}
	if m.to != nil {
		edges = append(edges, edgetype.EdgeTo)
	}
	if m.documents != nil {
		edges = append(edges, edgetype.EdgeDocuments)
	}
	if m.node_lists != nil {
		edges = append(edges, edgetype.EdgeNodeLists)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EdgeTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case edgetype.EdgeFrom:
		if id := m.from; id != nil {
			return []ent.Value{*id}
		}
	case edgetype.EdgeTo:
		if id := m.to; id != nil {
			return []ent.Value{*id}
		}
	case edgetype.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case edgetype.EdgeNodeLists:
		ids := make([]ent.Value, 0, len(m.node_lists))
		for id := range m.node_lists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EdgeTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddocuments != nil {
		edges = append(edges, edgetype.EdgeDocuments)
	}
	if m.removednode_lists != nil {
		edges = append(edges, edgetype.EdgeNodeLists)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EdgeTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case edgetype.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case edgetype.EdgeNodeLists:
		ids := make([]ent.Value, 0, len(m.removednode_lists))
		for id := range m.removednode_lists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EdgeTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedfrom {
		edges = append(edges, edgetype.EdgeFrom)
	}
	if m.clearedto {
		edges = append(edges, edgetype.EdgeTo)
	}
	if m.cleareddocuments {
		edges = append(edges, edgetype.EdgeDocuments)
	}
	if m.clearednode_lists {
		edges = append(edges, edgetype.EdgeNodeLists)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EdgeTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case edgetype.EdgeFrom:
		return m.clearedfrom
	case edgetype.EdgeTo:
		return m.clearedto
	case edgetype.EdgeDocuments:
		return m.cleareddocuments
	case edgetype.EdgeNodeLists:
		return m.clearednode_lists
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EdgeTypeMutation) ClearEdge(name string) error {
	switch name {
	case edgetype.EdgeFrom:
		m.ClearFrom()
		return nil
	case edgetype.EdgeTo:
		m.ClearTo()
		return nil
	}
	return fmt.Errorf("unknown EdgeType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EdgeTypeMutation) ResetEdge(name string) error {
	switch name {
	case edgetype.EdgeFrom:
		m.ResetFrom()
		return nil
	case edgetype.EdgeTo:
		m.ResetTo()
		return nil
	case edgetype.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case edgetype.EdgeNodeLists:
		m.ResetNodeLists()
		return nil
	}
	return fmt.Errorf("unknown EdgeType edge %s", name)
}

// ExternalReferenceMutation represents an operation that mutates the ExternalReference nodes in the graph.
type ExternalReferenceMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	proto_message    **sbom.ExternalReference
	url              *string
	comment          *string
	authority        *string
	_type            *externalreference.Type
	clearedFields    map[string]struct{}
	hashes           map[uuid.UUID]struct{}
	removedhashes    map[uuid.UUID]struct{}
	clearedhashes    bool
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	nodes            map[uuid.UUID]struct{}
	removednodes     map[uuid.UUID]struct{}
	clearednodes     bool
	done             bool
	oldValue         func(context.Context) (*ExternalReference, error)
	predicates       []predicate.ExternalReference
}

var _ ent.Mutation = (*ExternalReferenceMutation)(nil)

// externalreferenceOption allows management of the mutation configuration using functional options.
type externalreferenceOption func(*ExternalReferenceMutation)

// newExternalReferenceMutation creates new mutation for the ExternalReference entity.
func newExternalReferenceMutation(c config, op Op, opts ...externalreferenceOption) *ExternalReferenceMutation {
	m := &ExternalReferenceMutation{
		config:        c,
		op:            op,
		typ:           TypeExternalReference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExternalReferenceID sets the ID field of the mutation.
func withExternalReferenceID(id uuid.UUID) externalreferenceOption {
	return func(m *ExternalReferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *ExternalReference
		)
		m.oldValue = func(ctx context.Context) (*ExternalReference, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExternalReference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExternalReference sets the old ExternalReference of the mutation.
func withExternalReference(node *ExternalReference) externalreferenceOption {
	return func(m *ExternalReferenceMutation) {
		m.oldValue = func(context.Context) (*ExternalReference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExternalReferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExternalReferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExternalReference entities.
func (m *ExternalReferenceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExternalReferenceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExternalReferenceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExternalReference.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *ExternalReferenceMutation) SetProtoMessage(sr *sbom.ExternalReference) {
	m.proto_message = &sr
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *ExternalReferenceMutation) ProtoMessage() (r *sbom.ExternalReference, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the ExternalReference entity.
// If the ExternalReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalReferenceMutation) OldProtoMessage(ctx context.Context) (v *sbom.ExternalReference, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *ExternalReferenceMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetURL sets the "url" field.
func (m *ExternalReferenceMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ExternalReferenceMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ExternalReference entity.
// If the ExternalReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalReferenceMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ExternalReferenceMutation) ResetURL() {
	m.url = nil
}

// SetComment sets the "comment" field.
func (m *ExternalReferenceMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ExternalReferenceMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the ExternalReference entity.
// If the ExternalReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalReferenceMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *ExternalReferenceMutation) ResetComment() {
	m.comment = nil
}

// SetAuthority sets the "authority" field.
func (m *ExternalReferenceMutation) SetAuthority(s string) {
	m.authority = &s
}

// Authority returns the value of the "authority" field in the mutation.
func (m *ExternalReferenceMutation) Authority() (r string, exists bool) {
	v := m.authority
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthority returns the old "authority" field's value of the ExternalReference entity.
// If the ExternalReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalReferenceMutation) OldAuthority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthority: %w", err)
	}
	return oldValue.Authority, nil
}

// ClearAuthority clears the value of the "authority" field.
func (m *ExternalReferenceMutation) ClearAuthority() {
	m.authority = nil
	m.clearedFields[externalreference.FieldAuthority] = struct{}{}
}

// AuthorityCleared returns if the "authority" field was cleared in this mutation.
func (m *ExternalReferenceMutation) AuthorityCleared() bool {
	_, ok := m.clearedFields[externalreference.FieldAuthority]
	return ok
}

// ResetAuthority resets all changes to the "authority" field.
func (m *ExternalReferenceMutation) ResetAuthority() {
	m.authority = nil
	delete(m.clearedFields, externalreference.FieldAuthority)
}

// SetType sets the "type" field.
func (m *ExternalReferenceMutation) SetType(e externalreference.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *ExternalReferenceMutation) GetType() (r externalreference.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ExternalReference entity.
// If the ExternalReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalReferenceMutation) OldType(ctx context.Context) (v externalreference.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ExternalReferenceMutation) ResetType() {
	m._type = nil
}

// AddHashIDs adds the "hashes" edge to the HashesEntry entity by ids.
func (m *ExternalReferenceMutation) AddHashIDs(ids ...uuid.UUID) {
	if m.hashes == nil {
		m.hashes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hashes[ids[i]] = struct{}{}
	}
}

// ClearHashes clears the "hashes" edge to the HashesEntry entity.
func (m *ExternalReferenceMutation) ClearHashes() {
	m.clearedhashes = true
}

// HashesCleared reports if the "hashes" edge to the HashesEntry entity was cleared.
func (m *ExternalReferenceMutation) HashesCleared() bool {
	return m.clearedhashes
}

// RemoveHashIDs removes the "hashes" edge to the HashesEntry entity by IDs.
func (m *ExternalReferenceMutation) RemoveHashIDs(ids ...uuid.UUID) {
	if m.removedhashes == nil {
		m.removedhashes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hashes, ids[i])
		m.removedhashes[ids[i]] = struct{}{}
	}
}

// RemovedHashes returns the removed IDs of the "hashes" edge to the HashesEntry entity.
func (m *ExternalReferenceMutation) RemovedHashesIDs() (ids []uuid.UUID) {
	for id := range m.removedhashes {
		ids = append(ids, id)
	}
	return
}

// HashesIDs returns the "hashes" edge IDs in the mutation.
func (m *ExternalReferenceMutation) HashesIDs() (ids []uuid.UUID) {
	for id := range m.hashes {
		ids = append(ids, id)
	}
	return
}

// ResetHashes resets all changes to the "hashes" edge.
func (m *ExternalReferenceMutation) ResetHashes() {
	m.hashes = nil
	m.clearedhashes = false
	m.removedhashes = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *ExternalReferenceMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *ExternalReferenceMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *ExternalReferenceMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *ExternalReferenceMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *ExternalReferenceMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *ExternalReferenceMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *ExternalReferenceMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *ExternalReferenceMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *ExternalReferenceMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *ExternalReferenceMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *ExternalReferenceMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *ExternalReferenceMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *ExternalReferenceMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *ExternalReferenceMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the ExternalReferenceMutation builder.
func (m *ExternalReferenceMutation) Where(ps ...predicate.ExternalReference) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExternalReferenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExternalReferenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExternalReference, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExternalReferenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExternalReferenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExternalReference).
func (m *ExternalReferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExternalReferenceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.proto_message != nil {
		fields = append(fields, externalreference.FieldProtoMessage)
	}
	if m.url != nil {
		fields = append(fields, externalreference.FieldURL)
	}
	if m.comment != nil {
		fields = append(fields, externalreference.FieldComment)
	}
	if m.authority != nil {
		fields = append(fields, externalreference.FieldAuthority)
	}
	if m._type != nil {
		fields = append(fields, externalreference.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExternalReferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case externalreference.FieldProtoMessage:
		return m.ProtoMessage()
	case externalreference.FieldURL:
		return m.URL()
	case externalreference.FieldComment:
		return m.Comment()
	case externalreference.FieldAuthority:
		return m.Authority()
	case externalreference.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExternalReferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case externalreference.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case externalreference.FieldURL:
		return m.OldURL(ctx)
	case externalreference.FieldComment:
		return m.OldComment(ctx)
	case externalreference.FieldAuthority:
		return m.OldAuthority(ctx)
	case externalreference.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ExternalReference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExternalReferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case externalreference.FieldProtoMessage:
		v, ok := value.(*sbom.ExternalReference)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case externalreference.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case externalreference.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case externalreference.FieldAuthority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthority(v)
		return nil
	case externalreference.FieldType:
		v, ok := value.(externalreference.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ExternalReference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExternalReferenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExternalReferenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExternalReferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ExternalReference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExternalReferenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(externalreference.FieldAuthority) {
		fields = append(fields, externalreference.FieldAuthority)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExternalReferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExternalReferenceMutation) ClearField(name string) error {
	switch name {
	case externalreference.FieldAuthority:
		m.ClearAuthority()
		return nil
	}
	return fmt.Errorf("unknown ExternalReference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExternalReferenceMutation) ResetField(name string) error {
	switch name {
	case externalreference.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case externalreference.FieldURL:
		m.ResetURL()
		return nil
	case externalreference.FieldComment:
		m.ResetComment()
		return nil
	case externalreference.FieldAuthority:
		m.ResetAuthority()
		return nil
	case externalreference.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ExternalReference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExternalReferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.hashes != nil {
		edges = append(edges, externalreference.EdgeHashes)
	}
	if m.documents != nil {
		edges = append(edges, externalreference.EdgeDocuments)
	}
	if m.nodes != nil {
		edges = append(edges, externalreference.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExternalReferenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case externalreference.EdgeHashes:
		ids := make([]ent.Value, 0, len(m.hashes))
		for id := range m.hashes {
			ids = append(ids, id)
		}
		return ids
	case externalreference.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case externalreference.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExternalReferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedhashes != nil {
		edges = append(edges, externalreference.EdgeHashes)
	}
	if m.removeddocuments != nil {
		edges = append(edges, externalreference.EdgeDocuments)
	}
	if m.removednodes != nil {
		edges = append(edges, externalreference.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExternalReferenceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case externalreference.EdgeHashes:
		ids := make([]ent.Value, 0, len(m.removedhashes))
		for id := range m.removedhashes {
			ids = append(ids, id)
		}
		return ids
	case externalreference.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case externalreference.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExternalReferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhashes {
		edges = append(edges, externalreference.EdgeHashes)
	}
	if m.cleareddocuments {
		edges = append(edges, externalreference.EdgeDocuments)
	}
	if m.clearednodes {
		edges = append(edges, externalreference.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExternalReferenceMutation) EdgeCleared(name string) bool {
	switch name {
	case externalreference.EdgeHashes:
		return m.clearedhashes
	case externalreference.EdgeDocuments:
		return m.cleareddocuments
	case externalreference.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExternalReferenceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ExternalReference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExternalReferenceMutation) ResetEdge(name string) error {
	switch name {
	case externalreference.EdgeHashes:
		m.ResetHashes()
		return nil
	case externalreference.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case externalreference.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown ExternalReference edge %s", name)
}

// HashesEntryMutation represents an operation that mutates the HashesEntry nodes in the graph.
type HashesEntryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	hash_algorithm             *hashesentry.HashAlgorithm
	hash_data                  *string
	clearedFields              map[string]struct{}
	documents                  map[uuid.UUID]struct{}
	removeddocuments           map[uuid.UUID]struct{}
	cleareddocuments           bool
	external_references        map[uuid.UUID]struct{}
	removedexternal_references map[uuid.UUID]struct{}
	clearedexternal_references bool
	nodes                      map[uuid.UUID]struct{}
	removednodes               map[uuid.UUID]struct{}
	clearednodes               bool
	source_data                map[uuid.UUID]struct{}
	removedsource_data         map[uuid.UUID]struct{}
	clearedsource_data         bool
	done                       bool
	oldValue                   func(context.Context) (*HashesEntry, error)
	predicates                 []predicate.HashesEntry
}

var _ ent.Mutation = (*HashesEntryMutation)(nil)

// hashesentryOption allows management of the mutation configuration using functional options.
type hashesentryOption func(*HashesEntryMutation)

// newHashesEntryMutation creates new mutation for the HashesEntry entity.
func newHashesEntryMutation(c config, op Op, opts ...hashesentryOption) *HashesEntryMutation {
	m := &HashesEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeHashesEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHashesEntryID sets the ID field of the mutation.
func withHashesEntryID(id uuid.UUID) hashesentryOption {
	return func(m *HashesEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *HashesEntry
		)
		m.oldValue = func(ctx context.Context) (*HashesEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HashesEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHashesEntry sets the old HashesEntry of the mutation.
func withHashesEntry(node *HashesEntry) hashesentryOption {
	return func(m *HashesEntryMutation) {
		m.oldValue = func(context.Context) (*HashesEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HashesEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HashesEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HashesEntry entities.
func (m *HashesEntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HashesEntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HashesEntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HashesEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHashAlgorithm sets the "hash_algorithm" field.
func (m *HashesEntryMutation) SetHashAlgorithm(ha hashesentry.HashAlgorithm) {
	m.hash_algorithm = &ha
}

// HashAlgorithm returns the value of the "hash_algorithm" field in the mutation.
func (m *HashesEntryMutation) HashAlgorithm() (r hashesentry.HashAlgorithm, exists bool) {
	v := m.hash_algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldHashAlgorithm returns the old "hash_algorithm" field's value of the HashesEntry entity.
// If the HashesEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashesEntryMutation) OldHashAlgorithm(ctx context.Context) (v hashesentry.HashAlgorithm, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashAlgorithm: %w", err)
	}
	return oldValue.HashAlgorithm, nil
}

// ResetHashAlgorithm resets all changes to the "hash_algorithm" field.
func (m *HashesEntryMutation) ResetHashAlgorithm() {
	m.hash_algorithm = nil
}

// SetHashData sets the "hash_data" field.
func (m *HashesEntryMutation) SetHashData(s string) {
	m.hash_data = &s
}

// HashData returns the value of the "hash_data" field in the mutation.
func (m *HashesEntryMutation) HashData() (r string, exists bool) {
	v := m.hash_data
	if v == nil {
		return
	}
	return *v, true
}

// OldHashData returns the old "hash_data" field's value of the HashesEntry entity.
// If the HashesEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashesEntryMutation) OldHashData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashData: %w", err)
	}
	return oldValue.HashData, nil
}

// ResetHashData resets all changes to the "hash_data" field.
func (m *HashesEntryMutation) ResetHashData() {
	m.hash_data = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *HashesEntryMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *HashesEntryMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *HashesEntryMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *HashesEntryMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *HashesEntryMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *HashesEntryMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *HashesEntryMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddExternalReferenceIDs adds the "external_references" edge to the ExternalReference entity by ids.
func (m *HashesEntryMutation) AddExternalReferenceIDs(ids ...uuid.UUID) {
	if m.external_references == nil {
		m.external_references = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.external_references[ids[i]] = struct{}{}
	}
}

// ClearExternalReferences clears the "external_references" edge to the ExternalReference entity.
func (m *HashesEntryMutation) ClearExternalReferences() {
	m.clearedexternal_references = true
}

// ExternalReferencesCleared reports if the "external_references" edge to the ExternalReference entity was cleared.
func (m *HashesEntryMutation) ExternalReferencesCleared() bool {
	return m.clearedexternal_references
}

// RemoveExternalReferenceIDs removes the "external_references" edge to the ExternalReference entity by IDs.
func (m *HashesEntryMutation) RemoveExternalReferenceIDs(ids ...uuid.UUID) {
	if m.removedexternal_references == nil {
		m.removedexternal_references = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.external_references, ids[i])
		m.removedexternal_references[ids[i]] = struct{}{}
	}
}

// RemovedExternalReferences returns the removed IDs of the "external_references" edge to the ExternalReference entity.
func (m *HashesEntryMutation) RemovedExternalReferencesIDs() (ids []uuid.UUID) {
	for id := range m.removedexternal_references {
		ids = append(ids, id)
	}
	return
}

// ExternalReferencesIDs returns the "external_references" edge IDs in the mutation.
func (m *HashesEntryMutation) ExternalReferencesIDs() (ids []uuid.UUID) {
	for id := range m.external_references {
		ids = append(ids, id)
	}
	return
}

// ResetExternalReferences resets all changes to the "external_references" edge.
func (m *HashesEntryMutation) ResetExternalReferences() {
	m.external_references = nil
	m.clearedexternal_references = false
	m.removedexternal_references = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *HashesEntryMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *HashesEntryMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *HashesEntryMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *HashesEntryMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *HashesEntryMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *HashesEntryMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *HashesEntryMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddSourceDatumIDs adds the "source_data" edge to the SourceData entity by ids.
func (m *HashesEntryMutation) AddSourceDatumIDs(ids ...uuid.UUID) {
	if m.source_data == nil {
		m.source_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.source_data[ids[i]] = struct{}{}
	}
}

// ClearSourceData clears the "source_data" edge to the SourceData entity.
func (m *HashesEntryMutation) ClearSourceData() {
	m.clearedsource_data = true
}

// SourceDataCleared reports if the "source_data" edge to the SourceData entity was cleared.
func (m *HashesEntryMutation) SourceDataCleared() bool {
	return m.clearedsource_data
}

// RemoveSourceDatumIDs removes the "source_data" edge to the SourceData entity by IDs.
func (m *HashesEntryMutation) RemoveSourceDatumIDs(ids ...uuid.UUID) {
	if m.removedsource_data == nil {
		m.removedsource_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.source_data, ids[i])
		m.removedsource_data[ids[i]] = struct{}{}
	}
}

// RemovedSourceData returns the removed IDs of the "source_data" edge to the SourceData entity.
func (m *HashesEntryMutation) RemovedSourceDataIDs() (ids []uuid.UUID) {
	for id := range m.removedsource_data {
		ids = append(ids, id)
	}
	return
}

// SourceDataIDs returns the "source_data" edge IDs in the mutation.
func (m *HashesEntryMutation) SourceDataIDs() (ids []uuid.UUID) {
	for id := range m.source_data {
		ids = append(ids, id)
	}
	return
}

// ResetSourceData resets all changes to the "source_data" edge.
func (m *HashesEntryMutation) ResetSourceData() {
	m.source_data = nil
	m.clearedsource_data = false
	m.removedsource_data = nil
}

// Where appends a list predicates to the HashesEntryMutation builder.
func (m *HashesEntryMutation) Where(ps ...predicate.HashesEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HashesEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HashesEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HashesEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HashesEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HashesEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HashesEntry).
func (m *HashesEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HashesEntryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.hash_algorithm != nil {
		fields = append(fields, hashesentry.FieldHashAlgorithm)
	}
	if m.hash_data != nil {
		fields = append(fields, hashesentry.FieldHashData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HashesEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hashesentry.FieldHashAlgorithm:
		return m.HashAlgorithm()
	case hashesentry.FieldHashData:
		return m.HashData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HashesEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hashesentry.FieldHashAlgorithm:
		return m.OldHashAlgorithm(ctx)
	case hashesentry.FieldHashData:
		return m.OldHashData(ctx)
	}
	return nil, fmt.Errorf("unknown HashesEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HashesEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hashesentry.FieldHashAlgorithm:
		v, ok := value.(hashesentry.HashAlgorithm)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashAlgorithm(v)
		return nil
	case hashesentry.FieldHashData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashData(v)
		return nil
	}
	return fmt.Errorf("unknown HashesEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HashesEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HashesEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HashesEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HashesEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HashesEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HashesEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HashesEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HashesEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HashesEntryMutation) ResetField(name string) error {
	switch name {
	case hashesentry.FieldHashAlgorithm:
		m.ResetHashAlgorithm()
		return nil
	case hashesentry.FieldHashData:
		m.ResetHashData()
		return nil
	}
	return fmt.Errorf("unknown HashesEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HashesEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.documents != nil {
		edges = append(edges, hashesentry.EdgeDocuments)
	}
	if m.external_references != nil {
		edges = append(edges, hashesentry.EdgeExternalReferences)
	}
	if m.nodes != nil {
		edges = append(edges, hashesentry.EdgeNodes)
	}
	if m.source_data != nil {
		edges = append(edges, hashesentry.EdgeSourceData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HashesEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hashesentry.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case hashesentry.EdgeExternalReferences:
		ids := make([]ent.Value, 0, len(m.external_references))
		for id := range m.external_references {
			ids = append(ids, id)
		}
		return ids
	case hashesentry.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case hashesentry.EdgeSourceData:
		ids := make([]ent.Value, 0, len(m.source_data))
		for id := range m.source_data {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HashesEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddocuments != nil {
		edges = append(edges, hashesentry.EdgeDocuments)
	}
	if m.removedexternal_references != nil {
		edges = append(edges, hashesentry.EdgeExternalReferences)
	}
	if m.removednodes != nil {
		edges = append(edges, hashesentry.EdgeNodes)
	}
	if m.removedsource_data != nil {
		edges = append(edges, hashesentry.EdgeSourceData)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HashesEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hashesentry.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case hashesentry.EdgeExternalReferences:
		ids := make([]ent.Value, 0, len(m.removedexternal_references))
		for id := range m.removedexternal_references {
			ids = append(ids, id)
		}
		return ids
	case hashesentry.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case hashesentry.EdgeSourceData:
		ids := make([]ent.Value, 0, len(m.removedsource_data))
		for id := range m.removedsource_data {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HashesEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddocuments {
		edges = append(edges, hashesentry.EdgeDocuments)
	}
	if m.clearedexternal_references {
		edges = append(edges, hashesentry.EdgeExternalReferences)
	}
	if m.clearednodes {
		edges = append(edges, hashesentry.EdgeNodes)
	}
	if m.clearedsource_data {
		edges = append(edges, hashesentry.EdgeSourceData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HashesEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case hashesentry.EdgeDocuments:
		return m.cleareddocuments
	case hashesentry.EdgeExternalReferences:
		return m.clearedexternal_references
	case hashesentry.EdgeNodes:
		return m.clearednodes
	case hashesentry.EdgeSourceData:
		return m.clearedsource_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HashesEntryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HashesEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HashesEntryMutation) ResetEdge(name string) error {
	switch name {
	case hashesentry.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case hashesentry.EdgeExternalReferences:
		m.ResetExternalReferences()
		return nil
	case hashesentry.EdgeNodes:
		m.ResetNodes()
		return nil
	case hashesentry.EdgeSourceData:
		m.ResetSourceData()
		return nil
	}
	return fmt.Errorf("unknown HashesEntry edge %s", name)
}

// IdentifiersEntryMutation represents an operation that mutates the IdentifiersEntry nodes in the graph.
type IdentifiersEntryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	_type            *identifiersentry.Type
	value            *string
	clearedFields    map[string]struct{}
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	nodes            map[uuid.UUID]struct{}
	removednodes     map[uuid.UUID]struct{}
	clearednodes     bool
	done             bool
	oldValue         func(context.Context) (*IdentifiersEntry, error)
	predicates       []predicate.IdentifiersEntry
}

var _ ent.Mutation = (*IdentifiersEntryMutation)(nil)

// identifiersentryOption allows management of the mutation configuration using functional options.
type identifiersentryOption func(*IdentifiersEntryMutation)

// newIdentifiersEntryMutation creates new mutation for the IdentifiersEntry entity.
func newIdentifiersEntryMutation(c config, op Op, opts ...identifiersentryOption) *IdentifiersEntryMutation {
	m := &IdentifiersEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentifiersEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentifiersEntryID sets the ID field of the mutation.
func withIdentifiersEntryID(id uuid.UUID) identifiersentryOption {
	return func(m *IdentifiersEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *IdentifiersEntry
		)
		m.oldValue = func(ctx context.Context) (*IdentifiersEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IdentifiersEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentifiersEntry sets the old IdentifiersEntry of the mutation.
func withIdentifiersEntry(node *IdentifiersEntry) identifiersentryOption {
	return func(m *IdentifiersEntryMutation) {
		m.oldValue = func(context.Context) (*IdentifiersEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentifiersEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentifiersEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IdentifiersEntry entities.
func (m *IdentifiersEntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentifiersEntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentifiersEntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IdentifiersEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *IdentifiersEntryMutation) SetType(i identifiersentry.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *IdentifiersEntryMutation) GetType() (r identifiersentry.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IdentifiersEntry entity.
// If the IdentifiersEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentifiersEntryMutation) OldType(ctx context.Context) (v identifiersentry.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IdentifiersEntryMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *IdentifiersEntryMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *IdentifiersEntryMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the IdentifiersEntry entity.
// If the IdentifiersEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentifiersEntryMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *IdentifiersEntryMutation) ResetValue() {
	m.value = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *IdentifiersEntryMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *IdentifiersEntryMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *IdentifiersEntryMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *IdentifiersEntryMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *IdentifiersEntryMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *IdentifiersEntryMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *IdentifiersEntryMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *IdentifiersEntryMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *IdentifiersEntryMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *IdentifiersEntryMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *IdentifiersEntryMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *IdentifiersEntryMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *IdentifiersEntryMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *IdentifiersEntryMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the IdentifiersEntryMutation builder.
func (m *IdentifiersEntryMutation) Where(ps ...predicate.IdentifiersEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdentifiersEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdentifiersEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IdentifiersEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdentifiersEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdentifiersEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IdentifiersEntry).
func (m *IdentifiersEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentifiersEntryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, identifiersentry.FieldType)
	}
	if m.value != nil {
		fields = append(fields, identifiersentry.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentifiersEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identifiersentry.FieldType:
		return m.GetType()
	case identifiersentry.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentifiersEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identifiersentry.FieldType:
		return m.OldType(ctx)
	case identifiersentry.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown IdentifiersEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentifiersEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identifiersentry.FieldType:
		v, ok := value.(identifiersentry.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case identifiersentry.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown IdentifiersEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentifiersEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentifiersEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentifiersEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IdentifiersEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentifiersEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentifiersEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentifiersEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IdentifiersEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentifiersEntryMutation) ResetField(name string) error {
	switch name {
	case identifiersentry.FieldType:
		m.ResetType()
		return nil
	case identifiersentry.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown IdentifiersEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentifiersEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.documents != nil {
		edges = append(edges, identifiersentry.EdgeDocuments)
	}
	if m.nodes != nil {
		edges = append(edges, identifiersentry.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentifiersEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identifiersentry.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case identifiersentry.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentifiersEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddocuments != nil {
		edges = append(edges, identifiersentry.EdgeDocuments)
	}
	if m.removednodes != nil {
		edges = append(edges, identifiersentry.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentifiersEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case identifiersentry.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case identifiersentry.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentifiersEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddocuments {
		edges = append(edges, identifiersentry.EdgeDocuments)
	}
	if m.clearednodes {
		edges = append(edges, identifiersentry.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentifiersEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case identifiersentry.EdgeDocuments:
		return m.cleareddocuments
	case identifiersentry.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentifiersEntryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IdentifiersEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentifiersEntryMutation) ResetEdge(name string) error {
	switch name {
	case identifiersentry.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case identifiersentry.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown IdentifiersEntry edge %s", name)
}

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	proto_message         **sbom.Metadata
	native_id             *string
	version               *string
	name                  *string
	date                  *time.Time
	comment               *string
	clearedFields         map[string]struct{}
	tools                 map[uuid.UUID]struct{}
	removedtools          map[uuid.UUID]struct{}
	clearedtools          bool
	authors               map[uuid.UUID]struct{}
	removedauthors        map[uuid.UUID]struct{}
	clearedauthors        bool
	document_types        map[uuid.UUID]struct{}
	removeddocument_types map[uuid.UUID]struct{}
	cleareddocument_types bool
	source_data           *uuid.UUID
	clearedsource_data    bool
	documents             map[uuid.UUID]struct{}
	removeddocuments      map[uuid.UUID]struct{}
	cleareddocuments      bool
	done                  bool
	oldValue              func(context.Context) (*Metadata, error)
	predicates            []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id uuid.UUID) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metadata entities.
func (m *MetadataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *MetadataMutation) SetProtoMessage(s *sbom.Metadata) {
	m.proto_message = &s
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *MetadataMutation) ProtoMessage() (r *sbom.Metadata, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldProtoMessage(ctx context.Context) (v *sbom.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *MetadataMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetSourceDataID sets the "source_data_id" field.
func (m *MetadataMutation) SetSourceDataID(u uuid.UUID) {
	m.source_data = &u
}

// SourceDataID returns the value of the "source_data_id" field in the mutation.
func (m *MetadataMutation) SourceDataID() (r uuid.UUID, exists bool) {
	v := m.source_data
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceDataID returns the old "source_data_id" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldSourceDataID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceDataID: %w", err)
	}
	return oldValue.SourceDataID, nil
}

// ClearSourceDataID clears the value of the "source_data_id" field.
func (m *MetadataMutation) ClearSourceDataID() {
	m.source_data = nil
	m.clearedFields[metadata.FieldSourceDataID] = struct{}{}
}

// SourceDataIDCleared returns if the "source_data_id" field was cleared in this mutation.
func (m *MetadataMutation) SourceDataIDCleared() bool {
	_, ok := m.clearedFields[metadata.FieldSourceDataID]
	return ok
}

// ResetSourceDataID resets all changes to the "source_data_id" field.
func (m *MetadataMutation) ResetSourceDataID() {
	m.source_data = nil
	delete(m.clearedFields, metadata.FieldSourceDataID)
}

// SetNativeID sets the "native_id" field.
func (m *MetadataMutation) SetNativeID(s string) {
	m.native_id = &s
}

// NativeID returns the value of the "native_id" field in the mutation.
func (m *MetadataMutation) NativeID() (r string, exists bool) {
	v := m.native_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNativeID returns the old "native_id" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldNativeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNativeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNativeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNativeID: %w", err)
	}
	return oldValue.NativeID, nil
}

// ResetNativeID resets all changes to the "native_id" field.
func (m *MetadataMutation) ResetNativeID() {
	m.native_id = nil
}

// SetVersion sets the "version" field.
func (m *MetadataMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *MetadataMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *MetadataMutation) ResetVersion() {
	m.version = nil
}

// SetName sets the "name" field.
func (m *MetadataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MetadataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MetadataMutation) ResetName() {
	m.name = nil
}

// SetDate sets the "date" field.
func (m *MetadataMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *MetadataMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *MetadataMutation) ResetDate() {
	m.date = nil
}

// SetComment sets the "comment" field.
func (m *MetadataMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *MetadataMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *MetadataMutation) ResetComment() {
	m.comment = nil
}

// AddToolIDs adds the "tools" edge to the Tool entity by ids.
func (m *MetadataMutation) AddToolIDs(ids ...uuid.UUID) {
	if m.tools == nil {
		m.tools = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tools[ids[i]] = struct{}{}
	}
}

// ClearTools clears the "tools" edge to the Tool entity.
func (m *MetadataMutation) ClearTools() {
	m.clearedtools = true
}

// ToolsCleared reports if the "tools" edge to the Tool entity was cleared.
func (m *MetadataMutation) ToolsCleared() bool {
	return m.clearedtools
}

// RemoveToolIDs removes the "tools" edge to the Tool entity by IDs.
func (m *MetadataMutation) RemoveToolIDs(ids ...uuid.UUID) {
	if m.removedtools == nil {
		m.removedtools = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tools, ids[i])
		m.removedtools[ids[i]] = struct{}{}
	}
}

// RemovedTools returns the removed IDs of the "tools" edge to the Tool entity.
func (m *MetadataMutation) RemovedToolsIDs() (ids []uuid.UUID) {
	for id := range m.removedtools {
		ids = append(ids, id)
	}
	return
}

// ToolsIDs returns the "tools" edge IDs in the mutation.
func (m *MetadataMutation) ToolsIDs() (ids []uuid.UUID) {
	for id := range m.tools {
		ids = append(ids, id)
	}
	return
}

// ResetTools resets all changes to the "tools" edge.
func (m *MetadataMutation) ResetTools() {
	m.tools = nil
	m.clearedtools = false
	m.removedtools = nil
}

// AddAuthorIDs adds the "authors" edge to the Person entity by ids.
func (m *MetadataMutation) AddAuthorIDs(ids ...uuid.UUID) {
	if m.authors == nil {
		m.authors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the Person entity.
func (m *MetadataMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the Person entity was cleared.
func (m *MetadataMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the Person entity by IDs.
func (m *MetadataMutation) RemoveAuthorIDs(ids ...uuid.UUID) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the Person entity.
func (m *MetadataMutation) RemovedAuthorsIDs() (ids []uuid.UUID) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *MetadataMutation) AuthorsIDs() (ids []uuid.UUID) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *MetadataMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// AddDocumentTypeIDs adds the "document_types" edge to the DocumentType entity by ids.
func (m *MetadataMutation) AddDocumentTypeIDs(ids ...uuid.UUID) {
	if m.document_types == nil {
		m.document_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.document_types[ids[i]] = struct{}{}
	}
}

// ClearDocumentTypes clears the "document_types" edge to the DocumentType entity.
func (m *MetadataMutation) ClearDocumentTypes() {
	m.cleareddocument_types = true
}

// DocumentTypesCleared reports if the "document_types" edge to the DocumentType entity was cleared.
func (m *MetadataMutation) DocumentTypesCleared() bool {
	return m.cleareddocument_types
}

// RemoveDocumentTypeIDs removes the "document_types" edge to the DocumentType entity by IDs.
func (m *MetadataMutation) RemoveDocumentTypeIDs(ids ...uuid.UUID) {
	if m.removeddocument_types == nil {
		m.removeddocument_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.document_types, ids[i])
		m.removeddocument_types[ids[i]] = struct{}{}
	}
}

// RemovedDocumentTypes returns the removed IDs of the "document_types" edge to the DocumentType entity.
func (m *MetadataMutation) RemovedDocumentTypesIDs() (ids []uuid.UUID) {
	for id := range m.removeddocument_types {
		ids = append(ids, id)
	}
	return
}

// DocumentTypesIDs returns the "document_types" edge IDs in the mutation.
func (m *MetadataMutation) DocumentTypesIDs() (ids []uuid.UUID) {
	for id := range m.document_types {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentTypes resets all changes to the "document_types" edge.
func (m *MetadataMutation) ResetDocumentTypes() {
	m.document_types = nil
	m.cleareddocument_types = false
	m.removeddocument_types = nil
}

// ClearSourceData clears the "source_data" edge to the SourceData entity.
func (m *MetadataMutation) ClearSourceData() {
	m.clearedsource_data = true
	m.clearedFields[metadata.FieldSourceDataID] = struct{}{}
}

// SourceDataCleared reports if the "source_data" edge to the SourceData entity was cleared.
func (m *MetadataMutation) SourceDataCleared() bool {
	return m.SourceDataIDCleared() || m.clearedsource_data
}

// SourceDataIDs returns the "source_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceDataID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) SourceDataIDs() (ids []uuid.UUID) {
	if id := m.source_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceData resets all changes to the "source_data" edge.
func (m *MetadataMutation) ResetSourceData() {
	m.source_data = nil
	m.clearedsource_data = false
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *MetadataMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *MetadataMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *MetadataMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *MetadataMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *MetadataMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *MetadataMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *MetadataMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.proto_message != nil {
		fields = append(fields, metadata.FieldProtoMessage)
	}
	if m.source_data != nil {
		fields = append(fields, metadata.FieldSourceDataID)
	}
	if m.native_id != nil {
		fields = append(fields, metadata.FieldNativeID)
	}
	if m.version != nil {
		fields = append(fields, metadata.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, metadata.FieldName)
	}
	if m.date != nil {
		fields = append(fields, metadata.FieldDate)
	}
	if m.comment != nil {
		fields = append(fields, metadata.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldProtoMessage:
		return m.ProtoMessage()
	case metadata.FieldSourceDataID:
		return m.SourceDataID()
	case metadata.FieldNativeID:
		return m.NativeID()
	case metadata.FieldVersion:
		return m.Version()
	case metadata.FieldName:
		return m.Name()
	case metadata.FieldDate:
		return m.Date()
	case metadata.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case metadata.FieldSourceDataID:
		return m.OldSourceDataID(ctx)
	case metadata.FieldNativeID:
		return m.OldNativeID(ctx)
	case metadata.FieldVersion:
		return m.OldVersion(ctx)
	case metadata.FieldName:
		return m.OldName(ctx)
	case metadata.FieldDate:
		return m.OldDate(ctx)
	case metadata.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldProtoMessage:
		v, ok := value.(*sbom.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case metadata.FieldSourceDataID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceDataID(v)
		return nil
	case metadata.FieldNativeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNativeID(v)
		return nil
	case metadata.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case metadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case metadata.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case metadata.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metadata.FieldSourceDataID) {
		fields = append(fields, metadata.FieldSourceDataID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	switch name {
	case metadata.FieldSourceDataID:
		m.ClearSourceDataID()
		return nil
	}
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case metadata.FieldSourceDataID:
		m.ResetSourceDataID()
		return nil
	case metadata.FieldNativeID:
		m.ResetNativeID()
		return nil
	case metadata.FieldVersion:
		m.ResetVersion()
		return nil
	case metadata.FieldName:
		m.ResetName()
		return nil
	case metadata.FieldDate:
		m.ResetDate()
		return nil
	case metadata.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tools != nil {
		edges = append(edges, metadata.EdgeTools)
	}
	if m.authors != nil {
		edges = append(edges, metadata.EdgeAuthors)
	}
	if m.document_types != nil {
		edges = append(edges, metadata.EdgeDocumentTypes)
	}
	if m.source_data != nil {
		edges = append(edges, metadata.EdgeSourceData)
	}
	if m.documents != nil {
		edges = append(edges, metadata.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeTools:
		ids := make([]ent.Value, 0, len(m.tools))
		for id := range m.tools {
			ids = append(ids, id)
		}
		return ids
	case metadata.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	case metadata.EdgeDocumentTypes:
		ids := make([]ent.Value, 0, len(m.document_types))
		for id := range m.document_types {
			ids = append(ids, id)
		}
		return ids
	case metadata.EdgeSourceData:
		if id := m.source_data; id != nil {
			return []ent.Value{*id}
		}
	case metadata.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtools != nil {
		edges = append(edges, metadata.EdgeTools)
	}
	if m.removedauthors != nil {
		edges = append(edges, metadata.EdgeAuthors)
	}
	if m.removeddocument_types != nil {
		edges = append(edges, metadata.EdgeDocumentTypes)
	}
	if m.removeddocuments != nil {
		edges = append(edges, metadata.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeTools:
		ids := make([]ent.Value, 0, len(m.removedtools))
		for id := range m.removedtools {
			ids = append(ids, id)
		}
		return ids
	case metadata.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	case metadata.EdgeDocumentTypes:
		ids := make([]ent.Value, 0, len(m.removeddocument_types))
		for id := range m.removeddocument_types {
			ids = append(ids, id)
		}
		return ids
	case metadata.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtools {
		edges = append(edges, metadata.EdgeTools)
	}
	if m.clearedauthors {
		edges = append(edges, metadata.EdgeAuthors)
	}
	if m.cleareddocument_types {
		edges = append(edges, metadata.EdgeDocumentTypes)
	}
	if m.clearedsource_data {
		edges = append(edges, metadata.EdgeSourceData)
	}
	if m.cleareddocuments {
		edges = append(edges, metadata.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeTools:
		return m.clearedtools
	case metadata.EdgeAuthors:
		return m.clearedauthors
	case metadata.EdgeDocumentTypes:
		return m.cleareddocument_types
	case metadata.EdgeSourceData:
		return m.clearedsource_data
	case metadata.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeSourceData:
		m.ClearSourceData()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeTools:
		m.ResetTools()
		return nil
	case metadata.EdgeAuthors:
		m.ResetAuthors()
		return nil
	case metadata.EdgeDocumentTypes:
		m.ResetDocumentTypes()
		return nil
	case metadata.EdgeSourceData:
		m.ResetSourceData()
		return nil
	case metadata.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	proto_message              **sbom.Node
	native_id                  *string
	_type                      *node.Type
	name                       *string
	version                    *string
	file_name                  *string
	url_home                   *string
	url_download               *string
	licenses                   *[]string
	appendlicenses             []string
	license_concluded          *string
	license_comments           *string
	copyright                  *string
	source_info                *string
	comment                    *string
	summary                    *string
	description                *string
	release_date               *time.Time
	build_date                 *time.Time
	valid_until_date           *time.Time
	attribution                *[]string
	appendattribution          []string
	file_types                 *[]string
	appendfile_types           []string
	clearedFields              map[string]struct{}
	annotations                map[int]struct{}
	removedannotations         map[int]struct{}
	clearedannotations         bool
	suppliers                  map[uuid.UUID]struct{}
	removedsuppliers           map[uuid.UUID]struct{}
	clearedsuppliers           bool
	originators                map[uuid.UUID]struct{}
	removedoriginators         map[uuid.UUID]struct{}
	clearedoriginators         bool
	external_references        map[uuid.UUID]struct{}
	removedexternal_references map[uuid.UUID]struct{}
	clearedexternal_references bool
	primary_purpose            map[int]struct{}
	removedprimary_purpose     map[int]struct{}
	clearedprimary_purpose     bool
	to_nodes                   map[uuid.UUID]struct{}
	removedto_nodes            map[uuid.UUID]struct{}
	clearedto_nodes            bool
	nodes                      map[uuid.UUID]struct{}
	removednodes               map[uuid.UUID]struct{}
	clearednodes               bool
	hashes                     map[uuid.UUID]struct{}
	removedhashes              map[uuid.UUID]struct{}
	clearedhashes              bool
	identifiers                map[uuid.UUID]struct{}
	removedidentifiers         map[uuid.UUID]struct{}
	clearedidentifiers         bool
	properties                 map[uuid.UUID]struct{}
	removedproperties          map[uuid.UUID]struct{}
	clearedproperties          bool
	documents                  map[uuid.UUID]struct{}
	removeddocuments           map[uuid.UUID]struct{}
	cleareddocuments           bool
	node_lists                 map[uuid.UUID]struct{}
	removednode_lists          map[uuid.UUID]struct{}
	clearednode_lists          bool
	edge_types                 map[uuid.UUID]struct{}
	removededge_types          map[uuid.UUID]struct{}
	clearededge_types          bool
	done                       bool
	oldValue                   func(context.Context) (*Node, error)
	predicates                 []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id uuid.UUID) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Node entities.
func (m *NodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Node.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *NodeMutation) SetProtoMessage(s *sbom.Node) {
	m.proto_message = &s
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *NodeMutation) ProtoMessage() (r *sbom.Node, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldProtoMessage(ctx context.Context) (v *sbom.Node, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *NodeMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetNativeID sets the "native_id" field.
func (m *NodeMutation) SetNativeID(s string) {
	m.native_id = &s
}

// NativeID returns the value of the "native_id" field in the mutation.
func (m *NodeMutation) NativeID() (r string, exists bool) {
	v := m.native_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNativeID returns the old "native_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldNativeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNativeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNativeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNativeID: %w", err)
	}
	return oldValue.NativeID, nil
}

// ResetNativeID resets all changes to the "native_id" field.
func (m *NodeMutation) ResetNativeID() {
	m.native_id = nil
}

// SetType sets the "type" field.
func (m *NodeMutation) SetType(n node.Type) {
	m._type = &n
}

// GetType returns the value of the "type" field in the mutation.
func (m *NodeMutation) GetType() (r node.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldType(ctx context.Context) (v node.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NodeMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NodeMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *NodeMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *NodeMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *NodeMutation) ResetVersion() {
	m.version = nil
}

// SetFileName sets the "file_name" field.
func (m *NodeMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *NodeMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *NodeMutation) ResetFileName() {
	m.file_name = nil
}

// SetURLHome sets the "url_home" field.
func (m *NodeMutation) SetURLHome(s string) {
	m.url_home = &s
}

// URLHome returns the value of the "url_home" field in the mutation.
func (m *NodeMutation) URLHome() (r string, exists bool) {
	v := m.url_home
	if v == nil {
		return
	}
	return *v, true
}

// OldURLHome returns the old "url_home" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldURLHome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLHome: %w", err)
	}
	return oldValue.URLHome, nil
}

// ResetURLHome resets all changes to the "url_home" field.
func (m *NodeMutation) ResetURLHome() {
	m.url_home = nil
}

// SetURLDownload sets the "url_download" field.
func (m *NodeMutation) SetURLDownload(s string) {
	m.url_download = &s
}

// URLDownload returns the value of the "url_download" field in the mutation.
func (m *NodeMutation) URLDownload() (r string, exists bool) {
	v := m.url_download
	if v == nil {
		return
	}
	return *v, true
}

// OldURLDownload returns the old "url_download" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldURLDownload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLDownload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLDownload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLDownload: %w", err)
	}
	return oldValue.URLDownload, nil
}

// ResetURLDownload resets all changes to the "url_download" field.
func (m *NodeMutation) ResetURLDownload() {
	m.url_download = nil
}

// SetLicenses sets the "licenses" field.
func (m *NodeMutation) SetLicenses(s []string) {
	m.licenses = &s
	m.appendlicenses = nil
}

// Licenses returns the value of the "licenses" field in the mutation.
func (m *NodeMutation) Licenses() (r []string, exists bool) {
	v := m.licenses
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenses returns the old "licenses" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldLicenses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenses: %w", err)
	}
	return oldValue.Licenses, nil
}

// AppendLicenses adds s to the "licenses" field.
func (m *NodeMutation) AppendLicenses(s []string) {
	m.appendlicenses = append(m.appendlicenses, s...)
}

// AppendedLicenses returns the list of values that were appended to the "licenses" field in this mutation.
func (m *NodeMutation) AppendedLicenses() ([]string, bool) {
	if len(m.appendlicenses) == 0 {
		return nil, false
	}
	return m.appendlicenses, true
}

// ResetLicenses resets all changes to the "licenses" field.
func (m *NodeMutation) ResetLicenses() {
	m.licenses = nil
	m.appendlicenses = nil
}

// SetLicenseConcluded sets the "license_concluded" field.
func (m *NodeMutation) SetLicenseConcluded(s string) {
	m.license_concluded = &s
}

// LicenseConcluded returns the value of the "license_concluded" field in the mutation.
func (m *NodeMutation) LicenseConcluded() (r string, exists bool) {
	v := m.license_concluded
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseConcluded returns the old "license_concluded" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldLicenseConcluded(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseConcluded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseConcluded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseConcluded: %w", err)
	}
	return oldValue.LicenseConcluded, nil
}

// ResetLicenseConcluded resets all changes to the "license_concluded" field.
func (m *NodeMutation) ResetLicenseConcluded() {
	m.license_concluded = nil
}

// SetLicenseComments sets the "license_comments" field.
func (m *NodeMutation) SetLicenseComments(s string) {
	m.license_comments = &s
}

// LicenseComments returns the value of the "license_comments" field in the mutation.
func (m *NodeMutation) LicenseComments() (r string, exists bool) {
	v := m.license_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseComments returns the old "license_comments" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldLicenseComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseComments: %w", err)
	}
	return oldValue.LicenseComments, nil
}

// ResetLicenseComments resets all changes to the "license_comments" field.
func (m *NodeMutation) ResetLicenseComments() {
	m.license_comments = nil
}

// SetCopyright sets the "copyright" field.
func (m *NodeMutation) SetCopyright(s string) {
	m.copyright = &s
}

// Copyright returns the value of the "copyright" field in the mutation.
func (m *NodeMutation) Copyright() (r string, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old "copyright" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCopyright(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyright is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ResetCopyright resets all changes to the "copyright" field.
func (m *NodeMutation) ResetCopyright() {
	m.copyright = nil
}

// SetSourceInfo sets the "source_info" field.
func (m *NodeMutation) SetSourceInfo(s string) {
	m.source_info = &s
}

// SourceInfo returns the value of the "source_info" field in the mutation.
func (m *NodeMutation) SourceInfo() (r string, exists bool) {
	v := m.source_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceInfo returns the old "source_info" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldSourceInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceInfo: %w", err)
	}
	return oldValue.SourceInfo, nil
}

// ResetSourceInfo resets all changes to the "source_info" field.
func (m *NodeMutation) ResetSourceInfo() {
	m.source_info = nil
}

// SetComment sets the "comment" field.
func (m *NodeMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *NodeMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *NodeMutation) ResetComment() {
	m.comment = nil
}

// SetSummary sets the "summary" field.
func (m *NodeMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *NodeMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *NodeMutation) ResetSummary() {
	m.summary = nil
}

// SetDescription sets the "description" field.
func (m *NodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NodeMutation) ResetDescription() {
	m.description = nil
}

// SetReleaseDate sets the "release_date" field.
func (m *NodeMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *NodeMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *NodeMutation) ResetReleaseDate() {
	m.release_date = nil
}

// SetBuildDate sets the "build_date" field.
func (m *NodeMutation) SetBuildDate(t time.Time) {
	m.build_date = &t
}

// BuildDate returns the value of the "build_date" field in the mutation.
func (m *NodeMutation) BuildDate() (r time.Time, exists bool) {
	v := m.build_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildDate returns the old "build_date" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldBuildDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildDate: %w", err)
	}
	return oldValue.BuildDate, nil
}

// ResetBuildDate resets all changes to the "build_date" field.
func (m *NodeMutation) ResetBuildDate() {
	m.build_date = nil
}

// SetValidUntilDate sets the "valid_until_date" field.
func (m *NodeMutation) SetValidUntilDate(t time.Time) {
	m.valid_until_date = &t
}

// ValidUntilDate returns the value of the "valid_until_date" field in the mutation.
func (m *NodeMutation) ValidUntilDate() (r time.Time, exists bool) {
	v := m.valid_until_date
	if v == nil {
		return
	}
	return *v, true
}

// OldValidUntilDate returns the old "valid_until_date" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldValidUntilDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidUntilDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidUntilDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidUntilDate: %w", err)
	}
	return oldValue.ValidUntilDate, nil
}

// ResetValidUntilDate resets all changes to the "valid_until_date" field.
func (m *NodeMutation) ResetValidUntilDate() {
	m.valid_until_date = nil
}

// SetAttribution sets the "attribution" field.
func (m *NodeMutation) SetAttribution(s []string) {
	m.attribution = &s
	m.appendattribution = nil
}

// Attribution returns the value of the "attribution" field in the mutation.
func (m *NodeMutation) Attribution() (r []string, exists bool) {
	v := m.attribution
	if v == nil {
		return
	}
	return *v, true
}

// OldAttribution returns the old "attribution" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAttribution(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttribution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttribution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttribution: %w", err)
	}
	return oldValue.Attribution, nil
}

// AppendAttribution adds s to the "attribution" field.
func (m *NodeMutation) AppendAttribution(s []string) {
	m.appendattribution = append(m.appendattribution, s...)
}

// AppendedAttribution returns the list of values that were appended to the "attribution" field in this mutation.
func (m *NodeMutation) AppendedAttribution() ([]string, bool) {
	if len(m.appendattribution) == 0 {
		return nil, false
	}
	return m.appendattribution, true
}

// ResetAttribution resets all changes to the "attribution" field.
func (m *NodeMutation) ResetAttribution() {
	m.attribution = nil
	m.appendattribution = nil
}

// SetFileTypes sets the "file_types" field.
func (m *NodeMutation) SetFileTypes(s []string) {
	m.file_types = &s
	m.appendfile_types = nil
}

// FileTypes returns the value of the "file_types" field in the mutation.
func (m *NodeMutation) FileTypes() (r []string, exists bool) {
	v := m.file_types
	if v == nil {
		return
	}
	return *v, true
}

// OldFileTypes returns the old "file_types" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldFileTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileTypes: %w", err)
	}
	return oldValue.FileTypes, nil
}

// AppendFileTypes adds s to the "file_types" field.
func (m *NodeMutation) AppendFileTypes(s []string) {
	m.appendfile_types = append(m.appendfile_types, s...)
}

// AppendedFileTypes returns the list of values that were appended to the "file_types" field in this mutation.
func (m *NodeMutation) AppendedFileTypes() ([]string, bool) {
	if len(m.appendfile_types) == 0 {
		return nil, false
	}
	return m.appendfile_types, true
}

// ResetFileTypes resets all changes to the "file_types" field.
func (m *NodeMutation) ResetFileTypes() {
	m.file_types = nil
	m.appendfile_types = nil
}

// AddAnnotationIDs adds the "annotations" edge to the Annotation entity by ids.
func (m *NodeMutation) AddAnnotationIDs(ids ...int) {
	if m.annotations == nil {
		m.annotations = make(map[int]struct{})
	}
	for i := range ids {
		m.annotations[ids[i]] = struct{}{}
	}
}

// ClearAnnotations clears the "annotations" edge to the Annotation entity.
func (m *NodeMutation) ClearAnnotations() {
	m.clearedannotations = true
}

// AnnotationsCleared reports if the "annotations" edge to the Annotation entity was cleared.
func (m *NodeMutation) AnnotationsCleared() bool {
	return m.clearedannotations
}

// RemoveAnnotationIDs removes the "annotations" edge to the Annotation entity by IDs.
func (m *NodeMutation) RemoveAnnotationIDs(ids ...int) {
	if m.removedannotations == nil {
		m.removedannotations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.annotations, ids[i])
		m.removedannotations[ids[i]] = struct{}{}
	}
}

// RemovedAnnotations returns the removed IDs of the "annotations" edge to the Annotation entity.
func (m *NodeMutation) RemovedAnnotationsIDs() (ids []int) {
	for id := range m.removedannotations {
		ids = append(ids, id)
	}
	return
}

// AnnotationsIDs returns the "annotations" edge IDs in the mutation.
func (m *NodeMutation) AnnotationsIDs() (ids []int) {
	for id := range m.annotations {
		ids = append(ids, id)
	}
	return
}

// ResetAnnotations resets all changes to the "annotations" edge.
func (m *NodeMutation) ResetAnnotations() {
	m.annotations = nil
	m.clearedannotations = false
	m.removedannotations = nil
}

// AddSupplierIDs adds the "suppliers" edge to the Person entity by ids.
func (m *NodeMutation) AddSupplierIDs(ids ...uuid.UUID) {
	if m.suppliers == nil {
		m.suppliers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.suppliers[ids[i]] = struct{}{}
	}
}

// ClearSuppliers clears the "suppliers" edge to the Person entity.
func (m *NodeMutation) ClearSuppliers() {
	m.clearedsuppliers = true
}

// SuppliersCleared reports if the "suppliers" edge to the Person entity was cleared.
func (m *NodeMutation) SuppliersCleared() bool {
	return m.clearedsuppliers
}

// RemoveSupplierIDs removes the "suppliers" edge to the Person entity by IDs.
func (m *NodeMutation) RemoveSupplierIDs(ids ...uuid.UUID) {
	if m.removedsuppliers == nil {
		m.removedsuppliers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.suppliers, ids[i])
		m.removedsuppliers[ids[i]] = struct{}{}
	}
}

// RemovedSuppliers returns the removed IDs of the "suppliers" edge to the Person entity.
func (m *NodeMutation) RemovedSuppliersIDs() (ids []uuid.UUID) {
	for id := range m.removedsuppliers {
		ids = append(ids, id)
	}
	return
}

// SuppliersIDs returns the "suppliers" edge IDs in the mutation.
func (m *NodeMutation) SuppliersIDs() (ids []uuid.UUID) {
	for id := range m.suppliers {
		ids = append(ids, id)
	}
	return
}

// ResetSuppliers resets all changes to the "suppliers" edge.
func (m *NodeMutation) ResetSuppliers() {
	m.suppliers = nil
	m.clearedsuppliers = false
	m.removedsuppliers = nil
}

// AddOriginatorIDs adds the "originators" edge to the Person entity by ids.
func (m *NodeMutation) AddOriginatorIDs(ids ...uuid.UUID) {
	if m.originators == nil {
		m.originators = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.originators[ids[i]] = struct{}{}
	}
}

// ClearOriginators clears the "originators" edge to the Person entity.
func (m *NodeMutation) ClearOriginators() {
	m.clearedoriginators = true
}

// OriginatorsCleared reports if the "originators" edge to the Person entity was cleared.
func (m *NodeMutation) OriginatorsCleared() bool {
	return m.clearedoriginators
}

// RemoveOriginatorIDs removes the "originators" edge to the Person entity by IDs.
func (m *NodeMutation) RemoveOriginatorIDs(ids ...uuid.UUID) {
	if m.removedoriginators == nil {
		m.removedoriginators = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.originators, ids[i])
		m.removedoriginators[ids[i]] = struct{}{}
	}
}

// RemovedOriginators returns the removed IDs of the "originators" edge to the Person entity.
func (m *NodeMutation) RemovedOriginatorsIDs() (ids []uuid.UUID) {
	for id := range m.removedoriginators {
		ids = append(ids, id)
	}
	return
}

// OriginatorsIDs returns the "originators" edge IDs in the mutation.
func (m *NodeMutation) OriginatorsIDs() (ids []uuid.UUID) {
	for id := range m.originators {
		ids = append(ids, id)
	}
	return
}

// ResetOriginators resets all changes to the "originators" edge.
func (m *NodeMutation) ResetOriginators() {
	m.originators = nil
	m.clearedoriginators = false
	m.removedoriginators = nil
}

// AddExternalReferenceIDs adds the "external_references" edge to the ExternalReference entity by ids.
func (m *NodeMutation) AddExternalReferenceIDs(ids ...uuid.UUID) {
	if m.external_references == nil {
		m.external_references = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.external_references[ids[i]] = struct{}{}
	}
}

// ClearExternalReferences clears the "external_references" edge to the ExternalReference entity.
func (m *NodeMutation) ClearExternalReferences() {
	m.clearedexternal_references = true
}

// ExternalReferencesCleared reports if the "external_references" edge to the ExternalReference entity was cleared.
func (m *NodeMutation) ExternalReferencesCleared() bool {
	return m.clearedexternal_references
}

// RemoveExternalReferenceIDs removes the "external_references" edge to the ExternalReference entity by IDs.
func (m *NodeMutation) RemoveExternalReferenceIDs(ids ...uuid.UUID) {
	if m.removedexternal_references == nil {
		m.removedexternal_references = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.external_references, ids[i])
		m.removedexternal_references[ids[i]] = struct{}{}
	}
}

// RemovedExternalReferences returns the removed IDs of the "external_references" edge to the ExternalReference entity.
func (m *NodeMutation) RemovedExternalReferencesIDs() (ids []uuid.UUID) {
	for id := range m.removedexternal_references {
		ids = append(ids, id)
	}
	return
}

// ExternalReferencesIDs returns the "external_references" edge IDs in the mutation.
func (m *NodeMutation) ExternalReferencesIDs() (ids []uuid.UUID) {
	for id := range m.external_references {
		ids = append(ids, id)
	}
	return
}

// ResetExternalReferences resets all changes to the "external_references" edge.
func (m *NodeMutation) ResetExternalReferences() {
	m.external_references = nil
	m.clearedexternal_references = false
	m.removedexternal_references = nil
}

// AddPrimaryPurposeIDs adds the "primary_purpose" edge to the Purpose entity by ids.
func (m *NodeMutation) AddPrimaryPurposeIDs(ids ...int) {
	if m.primary_purpose == nil {
		m.primary_purpose = make(map[int]struct{})
	}
	for i := range ids {
		m.primary_purpose[ids[i]] = struct{}{}
	}
}

// ClearPrimaryPurpose clears the "primary_purpose" edge to the Purpose entity.
func (m *NodeMutation) ClearPrimaryPurpose() {
	m.clearedprimary_purpose = true
}

// PrimaryPurposeCleared reports if the "primary_purpose" edge to the Purpose entity was cleared.
func (m *NodeMutation) PrimaryPurposeCleared() bool {
	return m.clearedprimary_purpose
}

// RemovePrimaryPurposeIDs removes the "primary_purpose" edge to the Purpose entity by IDs.
func (m *NodeMutation) RemovePrimaryPurposeIDs(ids ...int) {
	if m.removedprimary_purpose == nil {
		m.removedprimary_purpose = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.primary_purpose, ids[i])
		m.removedprimary_purpose[ids[i]] = struct{}{}
	}
}

// RemovedPrimaryPurpose returns the removed IDs of the "primary_purpose" edge to the Purpose entity.
func (m *NodeMutation) RemovedPrimaryPurposeIDs() (ids []int) {
	for id := range m.removedprimary_purpose {
		ids = append(ids, id)
	}
	return
}

// PrimaryPurposeIDs returns the "primary_purpose" edge IDs in the mutation.
func (m *NodeMutation) PrimaryPurposeIDs() (ids []int) {
	for id := range m.primary_purpose {
		ids = append(ids, id)
	}
	return
}

// ResetPrimaryPurpose resets all changes to the "primary_purpose" edge.
func (m *NodeMutation) ResetPrimaryPurpose() {
	m.primary_purpose = nil
	m.clearedprimary_purpose = false
	m.removedprimary_purpose = nil
}

// AddToNodeIDs adds the "to_nodes" edge to the Node entity by ids.
func (m *NodeMutation) AddToNodeIDs(ids ...uuid.UUID) {
	if m.to_nodes == nil {
		m.to_nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.to_nodes[ids[i]] = struct{}{}
	}
}

// ClearToNodes clears the "to_nodes" edge to the Node entity.
func (m *NodeMutation) ClearToNodes() {
	m.clearedto_nodes = true
}

// ToNodesCleared reports if the "to_nodes" edge to the Node entity was cleared.
func (m *NodeMutation) ToNodesCleared() bool {
	return m.clearedto_nodes
}

// RemoveToNodeIDs removes the "to_nodes" edge to the Node entity by IDs.
func (m *NodeMutation) RemoveToNodeIDs(ids ...uuid.UUID) {
	if m.removedto_nodes == nil {
		m.removedto_nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.to_nodes, ids[i])
		m.removedto_nodes[ids[i]] = struct{}{}
	}
}

// RemovedToNodes returns the removed IDs of the "to_nodes" edge to the Node entity.
func (m *NodeMutation) RemovedToNodesIDs() (ids []uuid.UUID) {
	for id := range m.removedto_nodes {
		ids = append(ids, id)
	}
	return
}

// ToNodesIDs returns the "to_nodes" edge IDs in the mutation.
func (m *NodeMutation) ToNodesIDs() (ids []uuid.UUID) {
	for id := range m.to_nodes {
		ids = append(ids, id)
	}
	return
}

// ResetToNodes resets all changes to the "to_nodes" edge.
func (m *NodeMutation) ResetToNodes() {
	m.to_nodes = nil
	m.clearedto_nodes = false
	m.removedto_nodes = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *NodeMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *NodeMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *NodeMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *NodeMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *NodeMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *NodeMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *NodeMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddHashIDs adds the "hashes" edge to the HashesEntry entity by ids.
func (m *NodeMutation) AddHashIDs(ids ...uuid.UUID) {
	if m.hashes == nil {
		m.hashes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hashes[ids[i]] = struct{}{}
	}
}

// ClearHashes clears the "hashes" edge to the HashesEntry entity.
func (m *NodeMutation) ClearHashes() {
	m.clearedhashes = true
}

// HashesCleared reports if the "hashes" edge to the HashesEntry entity was cleared.
func (m *NodeMutation) HashesCleared() bool {
	return m.clearedhashes
}

// RemoveHashIDs removes the "hashes" edge to the HashesEntry entity by IDs.
func (m *NodeMutation) RemoveHashIDs(ids ...uuid.UUID) {
	if m.removedhashes == nil {
		m.removedhashes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hashes, ids[i])
		m.removedhashes[ids[i]] = struct{}{}
	}
}

// RemovedHashes returns the removed IDs of the "hashes" edge to the HashesEntry entity.
func (m *NodeMutation) RemovedHashesIDs() (ids []uuid.UUID) {
	for id := range m.removedhashes {
		ids = append(ids, id)
	}
	return
}

// HashesIDs returns the "hashes" edge IDs in the mutation.
func (m *NodeMutation) HashesIDs() (ids []uuid.UUID) {
	for id := range m.hashes {
		ids = append(ids, id)
	}
	return
}

// ResetHashes resets all changes to the "hashes" edge.
func (m *NodeMutation) ResetHashes() {
	m.hashes = nil
	m.clearedhashes = false
	m.removedhashes = nil
}

// AddIdentifierIDs adds the "identifiers" edge to the IdentifiersEntry entity by ids.
func (m *NodeMutation) AddIdentifierIDs(ids ...uuid.UUID) {
	if m.identifiers == nil {
		m.identifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.identifiers[ids[i]] = struct{}{}
	}
}

// ClearIdentifiers clears the "identifiers" edge to the IdentifiersEntry entity.
func (m *NodeMutation) ClearIdentifiers() {
	m.clearedidentifiers = true
}

// IdentifiersCleared reports if the "identifiers" edge to the IdentifiersEntry entity was cleared.
func (m *NodeMutation) IdentifiersCleared() bool {
	return m.clearedidentifiers
}

// RemoveIdentifierIDs removes the "identifiers" edge to the IdentifiersEntry entity by IDs.
func (m *NodeMutation) RemoveIdentifierIDs(ids ...uuid.UUID) {
	if m.removedidentifiers == nil {
		m.removedidentifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.identifiers, ids[i])
		m.removedidentifiers[ids[i]] = struct{}{}
	}
}

// RemovedIdentifiers returns the removed IDs of the "identifiers" edge to the IdentifiersEntry entity.
func (m *NodeMutation) RemovedIdentifiersIDs() (ids []uuid.UUID) {
	for id := range m.removedidentifiers {
		ids = append(ids, id)
	}
	return
}

// IdentifiersIDs returns the "identifiers" edge IDs in the mutation.
func (m *NodeMutation) IdentifiersIDs() (ids []uuid.UUID) {
	for id := range m.identifiers {
		ids = append(ids, id)
	}
	return
}

// ResetIdentifiers resets all changes to the "identifiers" edge.
func (m *NodeMutation) ResetIdentifiers() {
	m.identifiers = nil
	m.clearedidentifiers = false
	m.removedidentifiers = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *NodeMutation) AddPropertyIDs(ids ...uuid.UUID) {
	if m.properties == nil {
		m.properties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *NodeMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *NodeMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *NodeMutation) RemovePropertyIDs(ids ...uuid.UUID) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *NodeMutation) RemovedPropertiesIDs() (ids []uuid.UUID) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *NodeMutation) PropertiesIDs() (ids []uuid.UUID) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *NodeMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *NodeMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *NodeMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *NodeMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *NodeMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *NodeMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *NodeMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *NodeMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddNodeListIDs adds the "node_lists" edge to the NodeList entity by ids.
func (m *NodeMutation) AddNodeListIDs(ids ...uuid.UUID) {
	if m.node_lists == nil {
		m.node_lists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.node_lists[ids[i]] = struct{}{}
	}
}

// ClearNodeLists clears the "node_lists" edge to the NodeList entity.
func (m *NodeMutation) ClearNodeLists() {
	m.clearednode_lists = true
}

// NodeListsCleared reports if the "node_lists" edge to the NodeList entity was cleared.
func (m *NodeMutation) NodeListsCleared() bool {
	return m.clearednode_lists
}

// RemoveNodeListIDs removes the "node_lists" edge to the NodeList entity by IDs.
func (m *NodeMutation) RemoveNodeListIDs(ids ...uuid.UUID) {
	if m.removednode_lists == nil {
		m.removednode_lists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.node_lists, ids[i])
		m.removednode_lists[ids[i]] = struct{}{}
	}
}

// RemovedNodeLists returns the removed IDs of the "node_lists" edge to the NodeList entity.
func (m *NodeMutation) RemovedNodeListsIDs() (ids []uuid.UUID) {
	for id := range m.removednode_lists {
		ids = append(ids, id)
	}
	return
}

// NodeListsIDs returns the "node_lists" edge IDs in the mutation.
func (m *NodeMutation) NodeListsIDs() (ids []uuid.UUID) {
	for id := range m.node_lists {
		ids = append(ids, id)
	}
	return
}

// ResetNodeLists resets all changes to the "node_lists" edge.
func (m *NodeMutation) ResetNodeLists() {
	m.node_lists = nil
	m.clearednode_lists = false
	m.removednode_lists = nil
}

// AddEdgeTypeIDs adds the "edge_types" edge to the EdgeType entity by ids.
func (m *NodeMutation) AddEdgeTypeIDs(ids ...uuid.UUID) {
	if m.edge_types == nil {
		m.edge_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.edge_types[ids[i]] = struct{}{}
	}
}

// ClearEdgeTypes clears the "edge_types" edge to the EdgeType entity.
func (m *NodeMutation) ClearEdgeTypes() {
	m.clearededge_types = true
}

// EdgeTypesCleared reports if the "edge_types" edge to the EdgeType entity was cleared.
func (m *NodeMutation) EdgeTypesCleared() bool {
	return m.clearededge_types
}

// RemoveEdgeTypeIDs removes the "edge_types" edge to the EdgeType entity by IDs.
func (m *NodeMutation) RemoveEdgeTypeIDs(ids ...uuid.UUID) {
	if m.removededge_types == nil {
		m.removededge_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.edge_types, ids[i])
		m.removededge_types[ids[i]] = struct{}{}
	}
}

// RemovedEdgeTypes returns the removed IDs of the "edge_types" edge to the EdgeType entity.
func (m *NodeMutation) RemovedEdgeTypesIDs() (ids []uuid.UUID) {
	for id := range m.removededge_types {
		ids = append(ids, id)
	}
	return
}

// EdgeTypesIDs returns the "edge_types" edge IDs in the mutation.
func (m *NodeMutation) EdgeTypesIDs() (ids []uuid.UUID) {
	for id := range m.edge_types {
		ids = append(ids, id)
	}
	return
}

// ResetEdgeTypes resets all changes to the "edge_types" edge.
func (m *NodeMutation) ResetEdgeTypes() {
	m.edge_types = nil
	m.clearededge_types = false
	m.removededge_types = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Node, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.proto_message != nil {
		fields = append(fields, node.FieldProtoMessage)
	}
	if m.native_id != nil {
		fields = append(fields, node.FieldNativeID)
	}
	if m._type != nil {
		fields = append(fields, node.FieldType)
	}
	if m.name != nil {
		fields = append(fields, node.FieldName)
	}
	if m.version != nil {
		fields = append(fields, node.FieldVersion)
	}
	if m.file_name != nil {
		fields = append(fields, node.FieldFileName)
	}
	if m.url_home != nil {
		fields = append(fields, node.FieldURLHome)
	}
	if m.url_download != nil {
		fields = append(fields, node.FieldURLDownload)
	}
	if m.licenses != nil {
		fields = append(fields, node.FieldLicenses)
	}
	if m.license_concluded != nil {
		fields = append(fields, node.FieldLicenseConcluded)
	}
	if m.license_comments != nil {
		fields = append(fields, node.FieldLicenseComments)
	}
	if m.copyright != nil {
		fields = append(fields, node.FieldCopyright)
	}
	if m.source_info != nil {
		fields = append(fields, node.FieldSourceInfo)
	}
	if m.comment != nil {
		fields = append(fields, node.FieldComment)
	}
	if m.summary != nil {
		fields = append(fields, node.FieldSummary)
	}
	if m.description != nil {
		fields = append(fields, node.FieldDescription)
	}
	if m.release_date != nil {
		fields = append(fields, node.FieldReleaseDate)
	}
	if m.build_date != nil {
		fields = append(fields, node.FieldBuildDate)
	}
	if m.valid_until_date != nil {
		fields = append(fields, node.FieldValidUntilDate)
	}
	if m.attribution != nil {
		fields = append(fields, node.FieldAttribution)
	}
	if m.file_types != nil {
		fields = append(fields, node.FieldFileTypes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldProtoMessage:
		return m.ProtoMessage()
	case node.FieldNativeID:
		return m.NativeID()
	case node.FieldType:
		return m.GetType()
	case node.FieldName:
		return m.Name()
	case node.FieldVersion:
		return m.Version()
	case node.FieldFileName:
		return m.FileName()
	case node.FieldURLHome:
		return m.URLHome()
	case node.FieldURLDownload:
		return m.URLDownload()
	case node.FieldLicenses:
		return m.Licenses()
	case node.FieldLicenseConcluded:
		return m.LicenseConcluded()
	case node.FieldLicenseComments:
		return m.LicenseComments()
	case node.FieldCopyright:
		return m.Copyright()
	case node.FieldSourceInfo:
		return m.SourceInfo()
	case node.FieldComment:
		return m.Comment()
	case node.FieldSummary:
		return m.Summary()
	case node.FieldDescription:
		return m.Description()
	case node.FieldReleaseDate:
		return m.ReleaseDate()
	case node.FieldBuildDate:
		return m.BuildDate()
	case node.FieldValidUntilDate:
		return m.ValidUntilDate()
	case node.FieldAttribution:
		return m.Attribution()
	case node.FieldFileTypes:
		return m.FileTypes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case node.FieldNativeID:
		return m.OldNativeID(ctx)
	case node.FieldType:
		return m.OldType(ctx)
	case node.FieldName:
		return m.OldName(ctx)
	case node.FieldVersion:
		return m.OldVersion(ctx)
	case node.FieldFileName:
		return m.OldFileName(ctx)
	case node.FieldURLHome:
		return m.OldURLHome(ctx)
	case node.FieldURLDownload:
		return m.OldURLDownload(ctx)
	case node.FieldLicenses:
		return m.OldLicenses(ctx)
	case node.FieldLicenseConcluded:
		return m.OldLicenseConcluded(ctx)
	case node.FieldLicenseComments:
		return m.OldLicenseComments(ctx)
	case node.FieldCopyright:
		return m.OldCopyright(ctx)
	case node.FieldSourceInfo:
		return m.OldSourceInfo(ctx)
	case node.FieldComment:
		return m.OldComment(ctx)
	case node.FieldSummary:
		return m.OldSummary(ctx)
	case node.FieldDescription:
		return m.OldDescription(ctx)
	case node.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case node.FieldBuildDate:
		return m.OldBuildDate(ctx)
	case node.FieldValidUntilDate:
		return m.OldValidUntilDate(ctx)
	case node.FieldAttribution:
		return m.OldAttribution(ctx)
	case node.FieldFileTypes:
		return m.OldFileTypes(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldProtoMessage:
		v, ok := value.(*sbom.Node)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case node.FieldNativeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNativeID(v)
		return nil
	case node.FieldType:
		v, ok := value.(node.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case node.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case node.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case node.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case node.FieldURLHome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLHome(v)
		return nil
	case node.FieldURLDownload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLDownload(v)
		return nil
	case node.FieldLicenses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenses(v)
		return nil
	case node.FieldLicenseConcluded:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseConcluded(v)
		return nil
	case node.FieldLicenseComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseComments(v)
		return nil
	case node.FieldCopyright:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case node.FieldSourceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceInfo(v)
		return nil
	case node.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case node.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case node.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case node.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case node.FieldBuildDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildDate(v)
		return nil
	case node.FieldValidUntilDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidUntilDate(v)
		return nil
	case node.FieldAttribution:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttribution(v)
		return nil
	case node.FieldFileTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileTypes(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case node.FieldNativeID:
		m.ResetNativeID()
		return nil
	case node.FieldType:
		m.ResetType()
		return nil
	case node.FieldName:
		m.ResetName()
		return nil
	case node.FieldVersion:
		m.ResetVersion()
		return nil
	case node.FieldFileName:
		m.ResetFileName()
		return nil
	case node.FieldURLHome:
		m.ResetURLHome()
		return nil
	case node.FieldURLDownload:
		m.ResetURLDownload()
		return nil
	case node.FieldLicenses:
		m.ResetLicenses()
		return nil
	case node.FieldLicenseConcluded:
		m.ResetLicenseConcluded()
		return nil
	case node.FieldLicenseComments:
		m.ResetLicenseComments()
		return nil
	case node.FieldCopyright:
		m.ResetCopyright()
		return nil
	case node.FieldSourceInfo:
		m.ResetSourceInfo()
		return nil
	case node.FieldComment:
		m.ResetComment()
		return nil
	case node.FieldSummary:
		m.ResetSummary()
		return nil
	case node.FieldDescription:
		m.ResetDescription()
		return nil
	case node.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case node.FieldBuildDate:
		m.ResetBuildDate()
		return nil
	case node.FieldValidUntilDate:
		m.ResetValidUntilDate()
		return nil
	case node.FieldAttribution:
		m.ResetAttribution()
		return nil
	case node.FieldFileTypes:
		m.ResetFileTypes()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.annotations != nil {
		edges = append(edges, node.EdgeAnnotations)
	}
	if m.suppliers != nil {
		edges = append(edges, node.EdgeSuppliers)
	}
	if m.originators != nil {
		edges = append(edges, node.EdgeOriginators)
	}
	if m.external_references != nil {
		edges = append(edges, node.EdgeExternalReferences)
	}
	if m.primary_purpose != nil {
		edges = append(edges, node.EdgePrimaryPurpose)
	}
	if m.to_nodes != nil {
		edges = append(edges, node.EdgeToNodes)
	}
	if m.nodes != nil {
		edges = append(edges, node.EdgeNodes)
	}
	if m.hashes != nil {
		edges = append(edges, node.EdgeHashes)
	}
	if m.identifiers != nil {
		edges = append(edges, node.EdgeIdentifiers)
	}
	if m.properties != nil {
		edges = append(edges, node.EdgeProperties)
	}
	if m.documents != nil {
		edges = append(edges, node.EdgeDocuments)
	}
	if m.node_lists != nil {
		edges = append(edges, node.EdgeNodeLists)
	}
	if m.edge_types != nil {
		edges = append(edges, node.EdgeEdgeTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.annotations))
		for id := range m.annotations {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.suppliers))
		for id := range m.suppliers {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeOriginators:
		ids := make([]ent.Value, 0, len(m.originators))
		for id := range m.originators {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeExternalReferences:
		ids := make([]ent.Value, 0, len(m.external_references))
		for id := range m.external_references {
			ids = append(ids, id)
		}
		return ids
	case node.EdgePrimaryPurpose:
		ids := make([]ent.Value, 0, len(m.primary_purpose))
		for id := range m.primary_purpose {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeToNodes:
		ids := make([]ent.Value, 0, len(m.to_nodes))
		for id := range m.to_nodes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeHashes:
		ids := make([]ent.Value, 0, len(m.hashes))
		for id := range m.hashes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.identifiers))
		for id := range m.identifiers {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeNodeLists:
		ids := make([]ent.Value, 0, len(m.node_lists))
		for id := range m.node_lists {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeEdgeTypes:
		ids := make([]ent.Value, 0, len(m.edge_types))
		for id := range m.edge_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedannotations != nil {
		edges = append(edges, node.EdgeAnnotations)
	}
	if m.removedsuppliers != nil {
		edges = append(edges, node.EdgeSuppliers)
	}
	if m.removedoriginators != nil {
		edges = append(edges, node.EdgeOriginators)
	}
	if m.removedexternal_references != nil {
		edges = append(edges, node.EdgeExternalReferences)
	}
	if m.removedprimary_purpose != nil {
		edges = append(edges, node.EdgePrimaryPurpose)
	}
	if m.removedto_nodes != nil {
		edges = append(edges, node.EdgeToNodes)
	}
	if m.removednodes != nil {
		edges = append(edges, node.EdgeNodes)
	}
	if m.removedhashes != nil {
		edges = append(edges, node.EdgeHashes)
	}
	if m.removedidentifiers != nil {
		edges = append(edges, node.EdgeIdentifiers)
	}
	if m.removedproperties != nil {
		edges = append(edges, node.EdgeProperties)
	}
	if m.removeddocuments != nil {
		edges = append(edges, node.EdgeDocuments)
	}
	if m.removednode_lists != nil {
		edges = append(edges, node.EdgeNodeLists)
	}
	if m.removededge_types != nil {
		edges = append(edges, node.EdgeEdgeTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.removedannotations))
		for id := range m.removedannotations {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.removedsuppliers))
		for id := range m.removedsuppliers {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeOriginators:
		ids := make([]ent.Value, 0, len(m.removedoriginators))
		for id := range m.removedoriginators {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeExternalReferences:
		ids := make([]ent.Value, 0, len(m.removedexternal_references))
		for id := range m.removedexternal_references {
			ids = append(ids, id)
		}
		return ids
	case node.EdgePrimaryPurpose:
		ids := make([]ent.Value, 0, len(m.removedprimary_purpose))
		for id := range m.removedprimary_purpose {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeToNodes:
		ids := make([]ent.Value, 0, len(m.removedto_nodes))
		for id := range m.removedto_nodes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeHashes:
		ids := make([]ent.Value, 0, len(m.removedhashes))
		for id := range m.removedhashes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.removedidentifiers))
		for id := range m.removedidentifiers {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeNodeLists:
		ids := make([]ent.Value, 0, len(m.removednode_lists))
		for id := range m.removednode_lists {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeEdgeTypes:
		ids := make([]ent.Value, 0, len(m.removededge_types))
		for id := range m.removededge_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedannotations {
		edges = append(edges, node.EdgeAnnotations)
	}
	if m.clearedsuppliers {
		edges = append(edges, node.EdgeSuppliers)
	}
	if m.clearedoriginators {
		edges = append(edges, node.EdgeOriginators)
	}
	if m.clearedexternal_references {
		edges = append(edges, node.EdgeExternalReferences)
	}
	if m.clearedprimary_purpose {
		edges = append(edges, node.EdgePrimaryPurpose)
	}
	if m.clearedto_nodes {
		edges = append(edges, node.EdgeToNodes)
	}
	if m.clearednodes {
		edges = append(edges, node.EdgeNodes)
	}
	if m.clearedhashes {
		edges = append(edges, node.EdgeHashes)
	}
	if m.clearedidentifiers {
		edges = append(edges, node.EdgeIdentifiers)
	}
	if m.clearedproperties {
		edges = append(edges, node.EdgeProperties)
	}
	if m.cleareddocuments {
		edges = append(edges, node.EdgeDocuments)
	}
	if m.clearednode_lists {
		edges = append(edges, node.EdgeNodeLists)
	}
	if m.clearededge_types {
		edges = append(edges, node.EdgeEdgeTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	switch name {
	case node.EdgeAnnotations:
		return m.clearedannotations
	case node.EdgeSuppliers:
		return m.clearedsuppliers
	case node.EdgeOriginators:
		return m.clearedoriginators
	case node.EdgeExternalReferences:
		return m.clearedexternal_references
	case node.EdgePrimaryPurpose:
		return m.clearedprimary_purpose
	case node.EdgeToNodes:
		return m.clearedto_nodes
	case node.EdgeNodes:
		return m.clearednodes
	case node.EdgeHashes:
		return m.clearedhashes
	case node.EdgeIdentifiers:
		return m.clearedidentifiers
	case node.EdgeProperties:
		return m.clearedproperties
	case node.EdgeDocuments:
		return m.cleareddocuments
	case node.EdgeNodeLists:
		return m.clearednode_lists
	case node.EdgeEdgeTypes:
		return m.clearededge_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	switch name {
	case node.EdgeAnnotations:
		m.ResetAnnotations()
		return nil
	case node.EdgeSuppliers:
		m.ResetSuppliers()
		return nil
	case node.EdgeOriginators:
		m.ResetOriginators()
		return nil
	case node.EdgeExternalReferences:
		m.ResetExternalReferences()
		return nil
	case node.EdgePrimaryPurpose:
		m.ResetPrimaryPurpose()
		return nil
	case node.EdgeToNodes:
		m.ResetToNodes()
		return nil
	case node.EdgeNodes:
		m.ResetNodes()
		return nil
	case node.EdgeHashes:
		m.ResetHashes()
		return nil
	case node.EdgeIdentifiers:
		m.ResetIdentifiers()
		return nil
	case node.EdgeProperties:
		m.ResetProperties()
		return nil
	case node.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case node.EdgeNodeLists:
		m.ResetNodeLists()
		return nil
	case node.EdgeEdgeTypes:
		m.ResetEdgeTypes()
		return nil
	}
	return fmt.Errorf("unknown Node edge %s", name)
}

// NodeListMutation represents an operation that mutates the NodeList nodes in the graph.
type NodeListMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	proto_message       **sbom.NodeList
	root_elements       *[]string
	appendroot_elements []string
	clearedFields       map[string]struct{}
	edge_types          map[uuid.UUID]struct{}
	removededge_types   map[uuid.UUID]struct{}
	clearededge_types   bool
	nodes               map[uuid.UUID]struct{}
	removednodes        map[uuid.UUID]struct{}
	clearednodes        bool
	documents           map[uuid.UUID]struct{}
	removeddocuments    map[uuid.UUID]struct{}
	cleareddocuments    bool
	done                bool
	oldValue            func(context.Context) (*NodeList, error)
	predicates          []predicate.NodeList
}

var _ ent.Mutation = (*NodeListMutation)(nil)

// nodelistOption allows management of the mutation configuration using functional options.
type nodelistOption func(*NodeListMutation)

// newNodeListMutation creates new mutation for the NodeList entity.
func newNodeListMutation(c config, op Op, opts ...nodelistOption) *NodeListMutation {
	m := &NodeListMutation{
		config:        c,
		op:            op,
		typ:           TypeNodeList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeListID sets the ID field of the mutation.
func withNodeListID(id uuid.UUID) nodelistOption {
	return func(m *NodeListMutation) {
		var (
			err   error
			once  sync.Once
			value *NodeList
		)
		m.oldValue = func(ctx context.Context) (*NodeList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NodeList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNodeList sets the old NodeList of the mutation.
func withNodeList(node *NodeList) nodelistOption {
	return func(m *NodeListMutation) {
		m.oldValue = func(context.Context) (*NodeList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NodeList entities.
func (m *NodeListMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeListMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeListMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NodeList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *NodeListMutation) SetProtoMessage(sl *sbom.NodeList) {
	m.proto_message = &sl
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *NodeListMutation) ProtoMessage() (r *sbom.NodeList, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the NodeList entity.
// If the NodeList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeListMutation) OldProtoMessage(ctx context.Context) (v *sbom.NodeList, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *NodeListMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetRootElements sets the "root_elements" field.
func (m *NodeListMutation) SetRootElements(s []string) {
	m.root_elements = &s
	m.appendroot_elements = nil
}

// RootElements returns the value of the "root_elements" field in the mutation.
func (m *NodeListMutation) RootElements() (r []string, exists bool) {
	v := m.root_elements
	if v == nil {
		return
	}
	return *v, true
}

// OldRootElements returns the old "root_elements" field's value of the NodeList entity.
// If the NodeList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeListMutation) OldRootElements(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootElements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootElements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootElements: %w", err)
	}
	return oldValue.RootElements, nil
}

// AppendRootElements adds s to the "root_elements" field.
func (m *NodeListMutation) AppendRootElements(s []string) {
	m.appendroot_elements = append(m.appendroot_elements, s...)
}

// AppendedRootElements returns the list of values that were appended to the "root_elements" field in this mutation.
func (m *NodeListMutation) AppendedRootElements() ([]string, bool) {
	if len(m.appendroot_elements) == 0 {
		return nil, false
	}
	return m.appendroot_elements, true
}

// ResetRootElements resets all changes to the "root_elements" field.
func (m *NodeListMutation) ResetRootElements() {
	m.root_elements = nil
	m.appendroot_elements = nil
}

// AddEdgeTypeIDs adds the "edge_types" edge to the EdgeType entity by ids.
func (m *NodeListMutation) AddEdgeTypeIDs(ids ...uuid.UUID) {
	if m.edge_types == nil {
		m.edge_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.edge_types[ids[i]] = struct{}{}
	}
}

// ClearEdgeTypes clears the "edge_types" edge to the EdgeType entity.
func (m *NodeListMutation) ClearEdgeTypes() {
	m.clearededge_types = true
}

// EdgeTypesCleared reports if the "edge_types" edge to the EdgeType entity was cleared.
func (m *NodeListMutation) EdgeTypesCleared() bool {
	return m.clearededge_types
}

// RemoveEdgeTypeIDs removes the "edge_types" edge to the EdgeType entity by IDs.
func (m *NodeListMutation) RemoveEdgeTypeIDs(ids ...uuid.UUID) {
	if m.removededge_types == nil {
		m.removededge_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.edge_types, ids[i])
		m.removededge_types[ids[i]] = struct{}{}
	}
}

// RemovedEdgeTypes returns the removed IDs of the "edge_types" edge to the EdgeType entity.
func (m *NodeListMutation) RemovedEdgeTypesIDs() (ids []uuid.UUID) {
	for id := range m.removededge_types {
		ids = append(ids, id)
	}
	return
}

// EdgeTypesIDs returns the "edge_types" edge IDs in the mutation.
func (m *NodeListMutation) EdgeTypesIDs() (ids []uuid.UUID) {
	for id := range m.edge_types {
		ids = append(ids, id)
	}
	return
}

// ResetEdgeTypes resets all changes to the "edge_types" edge.
func (m *NodeListMutation) ResetEdgeTypes() {
	m.edge_types = nil
	m.clearededge_types = false
	m.removededge_types = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *NodeListMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *NodeListMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *NodeListMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *NodeListMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *NodeListMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *NodeListMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *NodeListMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *NodeListMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *NodeListMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *NodeListMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *NodeListMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *NodeListMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *NodeListMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *NodeListMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the NodeListMutation builder.
func (m *NodeListMutation) Where(ps ...predicate.NodeList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NodeList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NodeList).
func (m *NodeListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeListMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.proto_message != nil {
		fields = append(fields, nodelist.FieldProtoMessage)
	}
	if m.root_elements != nil {
		fields = append(fields, nodelist.FieldRootElements)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nodelist.FieldProtoMessage:
		return m.ProtoMessage()
	case nodelist.FieldRootElements:
		return m.RootElements()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nodelist.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case nodelist.FieldRootElements:
		return m.OldRootElements(ctx)
	}
	return nil, fmt.Errorf("unknown NodeList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nodelist.FieldProtoMessage:
		v, ok := value.(*sbom.NodeList)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case nodelist.FieldRootElements:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootElements(v)
		return nil
	}
	return fmt.Errorf("unknown NodeList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NodeList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NodeList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeListMutation) ResetField(name string) error {
	switch name {
	case nodelist.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case nodelist.FieldRootElements:
		m.ResetRootElements()
		return nil
	}
	return fmt.Errorf("unknown NodeList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeListMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.edge_types != nil {
		edges = append(edges, nodelist.EdgeEdgeTypes)
	}
	if m.nodes != nil {
		edges = append(edges, nodelist.EdgeNodes)
	}
	if m.documents != nil {
		edges = append(edges, nodelist.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nodelist.EdgeEdgeTypes:
		ids := make([]ent.Value, 0, len(m.edge_types))
		for id := range m.edge_types {
			ids = append(ids, id)
		}
		return ids
	case nodelist.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case nodelist.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removededge_types != nil {
		edges = append(edges, nodelist.EdgeEdgeTypes)
	}
	if m.removednodes != nil {
		edges = append(edges, nodelist.EdgeNodes)
	}
	if m.removeddocuments != nil {
		edges = append(edges, nodelist.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nodelist.EdgeEdgeTypes:
		ids := make([]ent.Value, 0, len(m.removededge_types))
		for id := range m.removededge_types {
			ids = append(ids, id)
		}
		return ids
	case nodelist.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case nodelist.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearededge_types {
		edges = append(edges, nodelist.EdgeEdgeTypes)
	}
	if m.clearednodes {
		edges = append(edges, nodelist.EdgeNodes)
	}
	if m.cleareddocuments {
		edges = append(edges, nodelist.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeListMutation) EdgeCleared(name string) bool {
	switch name {
	case nodelist.EdgeEdgeTypes:
		return m.clearededge_types
	case nodelist.EdgeNodes:
		return m.clearednodes
	case nodelist.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeListMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NodeList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeListMutation) ResetEdge(name string) error {
	switch name {
	case nodelist.EdgeEdgeTypes:
		m.ResetEdgeTypes()
		return nil
	case nodelist.EdgeNodes:
		m.ResetNodes()
		return nil
	case nodelist.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown NodeList edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	proto_message           **sbom.Person
	name                    *string
	is_org                  *bool
	email                   *string
	url                     *string
	phone                   *string
	clearedFields           map[string]struct{}
	contact_owner           map[uuid.UUID]struct{}
	removedcontact_owner    map[uuid.UUID]struct{}
	clearedcontact_owner    bool
	contacts                map[uuid.UUID]struct{}
	removedcontacts         map[uuid.UUID]struct{}
	clearedcontacts         bool
	documents               map[uuid.UUID]struct{}
	removeddocuments        map[uuid.UUID]struct{}
	cleareddocuments        bool
	metadata                map[uuid.UUID]struct{}
	removedmetadata         map[uuid.UUID]struct{}
	clearedmetadata         bool
	originator_nodes        map[uuid.UUID]struct{}
	removedoriginator_nodes map[uuid.UUID]struct{}
	clearedoriginator_nodes bool
	supplier_nodes          map[uuid.UUID]struct{}
	removedsupplier_nodes   map[uuid.UUID]struct{}
	clearedsupplier_nodes   bool
	done                    bool
	oldValue                func(context.Context) (*Person, error)
	predicates              []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id uuid.UUID) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Person entities.
func (m *PersonMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *PersonMutation) SetProtoMessage(s *sbom.Person) {
	m.proto_message = &s
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *PersonMutation) ProtoMessage() (r *sbom.Person, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldProtoMessage(ctx context.Context) (v *sbom.Person, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *PersonMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetIsOrg sets the "is_org" field.
func (m *PersonMutation) SetIsOrg(b bool) {
	m.is_org = &b
}

// IsOrg returns the value of the "is_org" field in the mutation.
func (m *PersonMutation) IsOrg() (r bool, exists bool) {
	v := m.is_org
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOrg returns the old "is_org" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIsOrg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOrg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOrg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOrg: %w", err)
	}
	return oldValue.IsOrg, nil
}

// ResetIsOrg resets all changes to the "is_org" field.
func (m *PersonMutation) ResetIsOrg() {
	m.is_org = nil
}

// SetEmail sets the "email" field.
func (m *PersonMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PersonMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PersonMutation) ResetEmail() {
	m.email = nil
}

// SetURL sets the "url" field.
func (m *PersonMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PersonMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *PersonMutation) ResetURL() {
	m.url = nil
}

// SetPhone sets the "phone" field.
func (m *PersonMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PersonMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *PersonMutation) ResetPhone() {
	m.phone = nil
}

// AddContactOwnerIDs adds the "contact_owner" edge to the Person entity by ids.
func (m *PersonMutation) AddContactOwnerIDs(ids ...uuid.UUID) {
	if m.contact_owner == nil {
		m.contact_owner = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.contact_owner[ids[i]] = struct{}{}
	}
}

// ClearContactOwner clears the "contact_owner" edge to the Person entity.
func (m *PersonMutation) ClearContactOwner() {
	m.clearedcontact_owner = true
}

// ContactOwnerCleared reports if the "contact_owner" edge to the Person entity was cleared.
func (m *PersonMutation) ContactOwnerCleared() bool {
	return m.clearedcontact_owner
}

// RemoveContactOwnerIDs removes the "contact_owner" edge to the Person entity by IDs.
func (m *PersonMutation) RemoveContactOwnerIDs(ids ...uuid.UUID) {
	if m.removedcontact_owner == nil {
		m.removedcontact_owner = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.contact_owner, ids[i])
		m.removedcontact_owner[ids[i]] = struct{}{}
	}
}

// RemovedContactOwner returns the removed IDs of the "contact_owner" edge to the Person entity.
func (m *PersonMutation) RemovedContactOwnerIDs() (ids []uuid.UUID) {
	for id := range m.removedcontact_owner {
		ids = append(ids, id)
	}
	return
}

// ContactOwnerIDs returns the "contact_owner" edge IDs in the mutation.
func (m *PersonMutation) ContactOwnerIDs() (ids []uuid.UUID) {
	for id := range m.contact_owner {
		ids = append(ids, id)
	}
	return
}

// ResetContactOwner resets all changes to the "contact_owner" edge.
func (m *PersonMutation) ResetContactOwner() {
	m.contact_owner = nil
	m.clearedcontact_owner = false
	m.removedcontact_owner = nil
}

// AddContactIDs adds the "contacts" edge to the Person entity by ids.
func (m *PersonMutation) AddContactIDs(ids ...uuid.UUID) {
	if m.contacts == nil {
		m.contacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.contacts[ids[i]] = struct{}{}
	}
}

// ClearContacts clears the "contacts" edge to the Person entity.
func (m *PersonMutation) ClearContacts() {
	m.clearedcontacts = true
}

// ContactsCleared reports if the "contacts" edge to the Person entity was cleared.
func (m *PersonMutation) ContactsCleared() bool {
	return m.clearedcontacts
}

// RemoveContactIDs removes the "contacts" edge to the Person entity by IDs.
func (m *PersonMutation) RemoveContactIDs(ids ...uuid.UUID) {
	if m.removedcontacts == nil {
		m.removedcontacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.contacts, ids[i])
		m.removedcontacts[ids[i]] = struct{}{}
	}
}

// RemovedContacts returns the removed IDs of the "contacts" edge to the Person entity.
func (m *PersonMutation) RemovedContactsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontacts {
		ids = append(ids, id)
	}
	return
}

// ContactsIDs returns the "contacts" edge IDs in the mutation.
func (m *PersonMutation) ContactsIDs() (ids []uuid.UUID) {
	for id := range m.contacts {
		ids = append(ids, id)
	}
	return
}

// ResetContacts resets all changes to the "contacts" edge.
func (m *PersonMutation) ResetContacts() {
	m.contacts = nil
	m.clearedcontacts = false
	m.removedcontacts = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *PersonMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *PersonMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *PersonMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *PersonMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *PersonMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *PersonMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *PersonMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *PersonMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *PersonMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *PersonMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *PersonMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *PersonMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *PersonMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *PersonMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddOriginatorNodeIDs adds the "originator_nodes" edge to the Node entity by ids.
func (m *PersonMutation) AddOriginatorNodeIDs(ids ...uuid.UUID) {
	if m.originator_nodes == nil {
		m.originator_nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.originator_nodes[ids[i]] = struct{}{}
	}
}

// ClearOriginatorNodes clears the "originator_nodes" edge to the Node entity.
func (m *PersonMutation) ClearOriginatorNodes() {
	m.clearedoriginator_nodes = true
}

// OriginatorNodesCleared reports if the "originator_nodes" edge to the Node entity was cleared.
func (m *PersonMutation) OriginatorNodesCleared() bool {
	return m.clearedoriginator_nodes
}

// RemoveOriginatorNodeIDs removes the "originator_nodes" edge to the Node entity by IDs.
func (m *PersonMutation) RemoveOriginatorNodeIDs(ids ...uuid.UUID) {
	if m.removedoriginator_nodes == nil {
		m.removedoriginator_nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.originator_nodes, ids[i])
		m.removedoriginator_nodes[ids[i]] = struct{}{}
	}
}

// RemovedOriginatorNodes returns the removed IDs of the "originator_nodes" edge to the Node entity.
func (m *PersonMutation) RemovedOriginatorNodesIDs() (ids []uuid.UUID) {
	for id := range m.removedoriginator_nodes {
		ids = append(ids, id)
	}
	return
}

// OriginatorNodesIDs returns the "originator_nodes" edge IDs in the mutation.
func (m *PersonMutation) OriginatorNodesIDs() (ids []uuid.UUID) {
	for id := range m.originator_nodes {
		ids = append(ids, id)
	}
	return
}

// ResetOriginatorNodes resets all changes to the "originator_nodes" edge.
func (m *PersonMutation) ResetOriginatorNodes() {
	m.originator_nodes = nil
	m.clearedoriginator_nodes = false
	m.removedoriginator_nodes = nil
}

// AddSupplierNodeIDs adds the "supplier_nodes" edge to the Node entity by ids.
func (m *PersonMutation) AddSupplierNodeIDs(ids ...uuid.UUID) {
	if m.supplier_nodes == nil {
		m.supplier_nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.supplier_nodes[ids[i]] = struct{}{}
	}
}

// ClearSupplierNodes clears the "supplier_nodes" edge to the Node entity.
func (m *PersonMutation) ClearSupplierNodes() {
	m.clearedsupplier_nodes = true
}

// SupplierNodesCleared reports if the "supplier_nodes" edge to the Node entity was cleared.
func (m *PersonMutation) SupplierNodesCleared() bool {
	return m.clearedsupplier_nodes
}

// RemoveSupplierNodeIDs removes the "supplier_nodes" edge to the Node entity by IDs.
func (m *PersonMutation) RemoveSupplierNodeIDs(ids ...uuid.UUID) {
	if m.removedsupplier_nodes == nil {
		m.removedsupplier_nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.supplier_nodes, ids[i])
		m.removedsupplier_nodes[ids[i]] = struct{}{}
	}
}

// RemovedSupplierNodes returns the removed IDs of the "supplier_nodes" edge to the Node entity.
func (m *PersonMutation) RemovedSupplierNodesIDs() (ids []uuid.UUID) {
	for id := range m.removedsupplier_nodes {
		ids = append(ids, id)
	}
	return
}

// SupplierNodesIDs returns the "supplier_nodes" edge IDs in the mutation.
func (m *PersonMutation) SupplierNodesIDs() (ids []uuid.UUID) {
	for id := range m.supplier_nodes {
		ids = append(ids, id)
	}
	return
}

// ResetSupplierNodes resets all changes to the "supplier_nodes" edge.
func (m *PersonMutation) ResetSupplierNodes() {
	m.supplier_nodes = nil
	m.clearedsupplier_nodes = false
	m.removedsupplier_nodes = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Person, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.proto_message != nil {
		fields = append(fields, person.FieldProtoMessage)
	}
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.is_org != nil {
		fields = append(fields, person.FieldIsOrg)
	}
	if m.email != nil {
		fields = append(fields, person.FieldEmail)
	}
	if m.url != nil {
		fields = append(fields, person.FieldURL)
	}
	if m.phone != nil {
		fields = append(fields, person.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldProtoMessage:
		return m.ProtoMessage()
	case person.FieldName:
		return m.Name()
	case person.FieldIsOrg:
		return m.IsOrg()
	case person.FieldEmail:
		return m.Email()
	case person.FieldURL:
		return m.URL()
	case person.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldIsOrg:
		return m.OldIsOrg(ctx)
	case person.FieldEmail:
		return m.OldEmail(ctx)
	case person.FieldURL:
		return m.OldURL(ctx)
	case person.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldProtoMessage:
		v, ok := value.(*sbom.Person)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldIsOrg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOrg(v)
		return nil
	case person.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case person.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case person.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldIsOrg:
		m.ResetIsOrg()
		return nil
	case person.FieldEmail:
		m.ResetEmail()
		return nil
	case person.FieldURL:
		m.ResetURL()
		return nil
	case person.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.contact_owner != nil {
		edges = append(edges, person.EdgeContactOwner)
	}
	if m.contacts != nil {
		edges = append(edges, person.EdgeContacts)
	}
	if m.documents != nil {
		edges = append(edges, person.EdgeDocuments)
	}
	if m.metadata != nil {
		edges = append(edges, person.EdgeMetadata)
	}
	if m.originator_nodes != nil {
		edges = append(edges, person.EdgeOriginatorNodes)
	}
	if m.supplier_nodes != nil {
		edges = append(edges, person.EdgeSupplierNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeContactOwner:
		ids := make([]ent.Value, 0, len(m.contact_owner))
		for id := range m.contact_owner {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.contacts))
		for id := range m.contacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeOriginatorNodes:
		ids := make([]ent.Value, 0, len(m.originator_nodes))
		for id := range m.originator_nodes {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeSupplierNodes:
		ids := make([]ent.Value, 0, len(m.supplier_nodes))
		for id := range m.supplier_nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcontact_owner != nil {
		edges = append(edges, person.EdgeContactOwner)
	}
	if m.removedcontacts != nil {
		edges = append(edges, person.EdgeContacts)
	}
	if m.removeddocuments != nil {
		edges = append(edges, person.EdgeDocuments)
	}
	if m.removedmetadata != nil {
		edges = append(edges, person.EdgeMetadata)
	}
	if m.removedoriginator_nodes != nil {
		edges = append(edges, person.EdgeOriginatorNodes)
	}
	if m.removedsupplier_nodes != nil {
		edges = append(edges, person.EdgeSupplierNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeContactOwner:
		ids := make([]ent.Value, 0, len(m.removedcontact_owner))
		for id := range m.removedcontact_owner {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.removedcontacts))
		for id := range m.removedcontacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeOriginatorNodes:
		ids := make([]ent.Value, 0, len(m.removedoriginator_nodes))
		for id := range m.removedoriginator_nodes {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeSupplierNodes:
		ids := make([]ent.Value, 0, len(m.removedsupplier_nodes))
		for id := range m.removedsupplier_nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcontact_owner {
		edges = append(edges, person.EdgeContactOwner)
	}
	if m.clearedcontacts {
		edges = append(edges, person.EdgeContacts)
	}
	if m.cleareddocuments {
		edges = append(edges, person.EdgeDocuments)
	}
	if m.clearedmetadata {
		edges = append(edges, person.EdgeMetadata)
	}
	if m.clearedoriginator_nodes {
		edges = append(edges, person.EdgeOriginatorNodes)
	}
	if m.clearedsupplier_nodes {
		edges = append(edges, person.EdgeSupplierNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeContactOwner:
		return m.clearedcontact_owner
	case person.EdgeContacts:
		return m.clearedcontacts
	case person.EdgeDocuments:
		return m.cleareddocuments
	case person.EdgeMetadata:
		return m.clearedmetadata
	case person.EdgeOriginatorNodes:
		return m.clearedoriginator_nodes
	case person.EdgeSupplierNodes:
		return m.clearedsupplier_nodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeContactOwner:
		m.ResetContactOwner()
		return nil
	case person.EdgeContacts:
		m.ResetContacts()
		return nil
	case person.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case person.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case person.EdgeOriginatorNodes:
		m.ResetOriginatorNodes()
		return nil
	case person.EdgeSupplierNodes:
		m.ResetSupplierNodes()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	proto_message    **sbom.Property
	name             *string
	data             *string
	clearedFields    map[string]struct{}
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	nodes            map[uuid.UUID]struct{}
	removednodes     map[uuid.UUID]struct{}
	clearednodes     bool
	done             bool
	oldValue         func(context.Context) (*Property, error)
	predicates       []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id uuid.UUID) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Property entities.
func (m *PropertyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *PropertyMutation) SetProtoMessage(s *sbom.Property) {
	m.proto_message = &s
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *PropertyMutation) ProtoMessage() (r *sbom.Property, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldProtoMessage(ctx context.Context) (v *sbom.Property, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *PropertyMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetName sets the "name" field.
func (m *PropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PropertyMutation) ResetName() {
	m.name = nil
}

// SetData sets the "data" field.
func (m *PropertyMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *PropertyMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *PropertyMutation) ResetData() {
	m.data = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *PropertyMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *PropertyMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *PropertyMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *PropertyMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *PropertyMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *PropertyMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *PropertyMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *PropertyMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *PropertyMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *PropertyMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *PropertyMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *PropertyMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *PropertyMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *PropertyMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.proto_message != nil {
		fields = append(fields, property.FieldProtoMessage)
	}
	if m.name != nil {
		fields = append(fields, property.FieldName)
	}
	if m.data != nil {
		fields = append(fields, property.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldProtoMessage:
		return m.ProtoMessage()
	case property.FieldName:
		return m.Name()
	case property.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case property.FieldName:
		return m.OldName(ctx)
	case property.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldProtoMessage:
		v, ok := value.(*sbom.Property)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case property.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case property.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case property.FieldName:
		m.ResetName()
		return nil
	case property.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.documents != nil {
		edges = append(edges, property.EdgeDocuments)
	}
	if m.nodes != nil {
		edges = append(edges, property.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddocuments != nil {
		edges = append(edges, property.EdgeDocuments)
	}
	if m.removednodes != nil {
		edges = append(edges, property.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddocuments {
		edges = append(edges, property.EdgeDocuments)
	}
	if m.clearednodes {
		edges = append(edges, property.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeDocuments:
		return m.cleareddocuments
	case property.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case property.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// PurposeMutation represents an operation that mutates the Purpose nodes in the graph.
type PurposeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	primary_purpose  *purpose.PrimaryPurpose
	clearedFields    map[string]struct{}
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	nodes            map[uuid.UUID]struct{}
	removednodes     map[uuid.UUID]struct{}
	clearednodes     bool
	done             bool
	oldValue         func(context.Context) (*Purpose, error)
	predicates       []predicate.Purpose
}

var _ ent.Mutation = (*PurposeMutation)(nil)

// purposeOption allows management of the mutation configuration using functional options.
type purposeOption func(*PurposeMutation)

// newPurposeMutation creates new mutation for the Purpose entity.
func newPurposeMutation(c config, op Op, opts ...purposeOption) *PurposeMutation {
	m := &PurposeMutation{
		config:        c,
		op:            op,
		typ:           TypePurpose,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPurposeID sets the ID field of the mutation.
func withPurposeID(id int) purposeOption {
	return func(m *PurposeMutation) {
		var (
			err   error
			once  sync.Once
			value *Purpose
		)
		m.oldValue = func(ctx context.Context) (*Purpose, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Purpose.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPurpose sets the old Purpose of the mutation.
func withPurpose(node *Purpose) purposeOption {
	return func(m *PurposeMutation) {
		m.oldValue = func(context.Context) (*Purpose, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PurposeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PurposeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PurposeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PurposeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Purpose.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrimaryPurpose sets the "primary_purpose" field.
func (m *PurposeMutation) SetPrimaryPurpose(pp purpose.PrimaryPurpose) {
	m.primary_purpose = &pp
}

// PrimaryPurpose returns the value of the "primary_purpose" field in the mutation.
func (m *PurposeMutation) PrimaryPurpose() (r purpose.PrimaryPurpose, exists bool) {
	v := m.primary_purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryPurpose returns the old "primary_purpose" field's value of the Purpose entity.
// If the Purpose object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurposeMutation) OldPrimaryPurpose(ctx context.Context) (v purpose.PrimaryPurpose, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryPurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryPurpose: %w", err)
	}
	return oldValue.PrimaryPurpose, nil
}

// ResetPrimaryPurpose resets all changes to the "primary_purpose" field.
func (m *PurposeMutation) ResetPrimaryPurpose() {
	m.primary_purpose = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *PurposeMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *PurposeMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *PurposeMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *PurposeMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *PurposeMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *PurposeMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *PurposeMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *PurposeMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *PurposeMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *PurposeMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *PurposeMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *PurposeMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *PurposeMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *PurposeMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the PurposeMutation builder.
func (m *PurposeMutation) Where(ps ...predicate.Purpose) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PurposeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PurposeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Purpose, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PurposeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PurposeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Purpose).
func (m *PurposeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PurposeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.primary_purpose != nil {
		fields = append(fields, purpose.FieldPrimaryPurpose)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PurposeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case purpose.FieldPrimaryPurpose:
		return m.PrimaryPurpose()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PurposeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case purpose.FieldPrimaryPurpose:
		return m.OldPrimaryPurpose(ctx)
	}
	return nil, fmt.Errorf("unknown Purpose field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurposeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case purpose.FieldPrimaryPurpose:
		v, ok := value.(purpose.PrimaryPurpose)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryPurpose(v)
		return nil
	}
	return fmt.Errorf("unknown Purpose field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PurposeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PurposeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurposeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Purpose numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PurposeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PurposeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PurposeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Purpose nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PurposeMutation) ResetField(name string) error {
	switch name {
	case purpose.FieldPrimaryPurpose:
		m.ResetPrimaryPurpose()
		return nil
	}
	return fmt.Errorf("unknown Purpose field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PurposeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.documents != nil {
		edges = append(edges, purpose.EdgeDocuments)
	}
	if m.nodes != nil {
		edges = append(edges, purpose.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PurposeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case purpose.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case purpose.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PurposeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddocuments != nil {
		edges = append(edges, purpose.EdgeDocuments)
	}
	if m.removednodes != nil {
		edges = append(edges, purpose.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PurposeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case purpose.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case purpose.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PurposeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddocuments {
		edges = append(edges, purpose.EdgeDocuments)
	}
	if m.clearednodes {
		edges = append(edges, purpose.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PurposeMutation) EdgeCleared(name string) bool {
	switch name {
	case purpose.EdgeDocuments:
		return m.cleareddocuments
	case purpose.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PurposeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Purpose unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PurposeMutation) ResetEdge(name string) error {
	switch name {
	case purpose.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case purpose.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown Purpose edge %s", name)
}

// SourceDataMutation represents an operation that mutates the SourceData nodes in the graph.
type SourceDataMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	proto_message    **sbom.SourceData
	format           *string
	size             *int64
	addsize          *int64
	uri              *string
	clearedFields    map[string]struct{}
	hashes           map[uuid.UUID]struct{}
	removedhashes    map[uuid.UUID]struct{}
	clearedhashes    bool
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	metadata         map[uuid.UUID]struct{}
	removedmetadata  map[uuid.UUID]struct{}
	clearedmetadata  bool
	done             bool
	oldValue         func(context.Context) (*SourceData, error)
	predicates       []predicate.SourceData
}

var _ ent.Mutation = (*SourceDataMutation)(nil)

// sourcedataOption allows management of the mutation configuration using functional options.
type sourcedataOption func(*SourceDataMutation)

// newSourceDataMutation creates new mutation for the SourceData entity.
func newSourceDataMutation(c config, op Op, opts ...sourcedataOption) *SourceDataMutation {
	m := &SourceDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceDataID sets the ID field of the mutation.
func withSourceDataID(id uuid.UUID) sourcedataOption {
	return func(m *SourceDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceData
		)
		m.oldValue = func(ctx context.Context) (*SourceData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceData sets the old SourceData of the mutation.
func withSourceData(node *SourceData) sourcedataOption {
	return func(m *SourceDataMutation) {
		m.oldValue = func(context.Context) (*SourceData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceData entities.
func (m *SourceDataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceDataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceDataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *SourceDataMutation) SetProtoMessage(sd *sbom.SourceData) {
	m.proto_message = &sd
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *SourceDataMutation) ProtoMessage() (r *sbom.SourceData, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldProtoMessage(ctx context.Context) (v *sbom.SourceData, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *SourceDataMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetFormat sets the "format" field.
func (m *SourceDataMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *SourceDataMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *SourceDataMutation) ResetFormat() {
	m.format = nil
}

// SetSize sets the "size" field.
func (m *SourceDataMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *SourceDataMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *SourceDataMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *SourceDataMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *SourceDataMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetURI sets the "uri" field.
func (m *SourceDataMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *SourceDataMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ClearURI clears the value of the "uri" field.
func (m *SourceDataMutation) ClearURI() {
	m.uri = nil
	m.clearedFields[sourcedata.FieldURI] = struct{}{}
}

// URICleared returns if the "uri" field was cleared in this mutation.
func (m *SourceDataMutation) URICleared() bool {
	_, ok := m.clearedFields[sourcedata.FieldURI]
	return ok
}

// ResetURI resets all changes to the "uri" field.
func (m *SourceDataMutation) ResetURI() {
	m.uri = nil
	delete(m.clearedFields, sourcedata.FieldURI)
}

// AddHashIDs adds the "hashes" edge to the HashesEntry entity by ids.
func (m *SourceDataMutation) AddHashIDs(ids ...uuid.UUID) {
	if m.hashes == nil {
		m.hashes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hashes[ids[i]] = struct{}{}
	}
}

// ClearHashes clears the "hashes" edge to the HashesEntry entity.
func (m *SourceDataMutation) ClearHashes() {
	m.clearedhashes = true
}

// HashesCleared reports if the "hashes" edge to the HashesEntry entity was cleared.
func (m *SourceDataMutation) HashesCleared() bool {
	return m.clearedhashes
}

// RemoveHashIDs removes the "hashes" edge to the HashesEntry entity by IDs.
func (m *SourceDataMutation) RemoveHashIDs(ids ...uuid.UUID) {
	if m.removedhashes == nil {
		m.removedhashes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hashes, ids[i])
		m.removedhashes[ids[i]] = struct{}{}
	}
}

// RemovedHashes returns the removed IDs of the "hashes" edge to the HashesEntry entity.
func (m *SourceDataMutation) RemovedHashesIDs() (ids []uuid.UUID) {
	for id := range m.removedhashes {
		ids = append(ids, id)
	}
	return
}

// HashesIDs returns the "hashes" edge IDs in the mutation.
func (m *SourceDataMutation) HashesIDs() (ids []uuid.UUID) {
	for id := range m.hashes {
		ids = append(ids, id)
	}
	return
}

// ResetHashes resets all changes to the "hashes" edge.
func (m *SourceDataMutation) ResetHashes() {
	m.hashes = nil
	m.clearedhashes = false
	m.removedhashes = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *SourceDataMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *SourceDataMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *SourceDataMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *SourceDataMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *SourceDataMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *SourceDataMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *SourceDataMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *SourceDataMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *SourceDataMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *SourceDataMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *SourceDataMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *SourceDataMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *SourceDataMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *SourceDataMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// Where appends a list predicates to the SourceDataMutation builder.
func (m *SourceDataMutation) Where(ps ...predicate.SourceData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceData).
func (m *SourceDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceDataMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.proto_message != nil {
		fields = append(fields, sourcedata.FieldProtoMessage)
	}
	if m.format != nil {
		fields = append(fields, sourcedata.FieldFormat)
	}
	if m.size != nil {
		fields = append(fields, sourcedata.FieldSize)
	}
	if m.uri != nil {
		fields = append(fields, sourcedata.FieldURI)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcedata.FieldProtoMessage:
		return m.ProtoMessage()
	case sourcedata.FieldFormat:
		return m.Format()
	case sourcedata.FieldSize:
		return m.Size()
	case sourcedata.FieldURI:
		return m.URI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcedata.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case sourcedata.FieldFormat:
		return m.OldFormat(ctx)
	case sourcedata.FieldSize:
		return m.OldSize(ctx)
	case sourcedata.FieldURI:
		return m.OldURI(ctx)
	}
	return nil, fmt.Errorf("unknown SourceData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcedata.FieldProtoMessage:
		v, ok := value.(*sbom.SourceData)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case sourcedata.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case sourcedata.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case sourcedata.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	}
	return fmt.Errorf("unknown SourceData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceDataMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, sourcedata.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sourcedata.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sourcedata.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown SourceData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourcedata.FieldURI) {
		fields = append(fields, sourcedata.FieldURI)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceDataMutation) ClearField(name string) error {
	switch name {
	case sourcedata.FieldURI:
		m.ClearURI()
		return nil
	}
	return fmt.Errorf("unknown SourceData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceDataMutation) ResetField(name string) error {
	switch name {
	case sourcedata.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case sourcedata.FieldFormat:
		m.ResetFormat()
		return nil
	case sourcedata.FieldSize:
		m.ResetSize()
		return nil
	case sourcedata.FieldURI:
		m.ResetURI()
		return nil
	}
	return fmt.Errorf("unknown SourceData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.hashes != nil {
		edges = append(edges, sourcedata.EdgeHashes)
	}
	if m.documents != nil {
		edges = append(edges, sourcedata.EdgeDocuments)
	}
	if m.metadata != nil {
		edges = append(edges, sourcedata.EdgeMetadata)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcedata.EdgeHashes:
		ids := make([]ent.Value, 0, len(m.hashes))
		for id := range m.hashes {
			ids = append(ids, id)
		}
		return ids
	case sourcedata.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case sourcedata.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedhashes != nil {
		edges = append(edges, sourcedata.EdgeHashes)
	}
	if m.removeddocuments != nil {
		edges = append(edges, sourcedata.EdgeDocuments)
	}
	if m.removedmetadata != nil {
		edges = append(edges, sourcedata.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcedata.EdgeHashes:
		ids := make([]ent.Value, 0, len(m.removedhashes))
		for id := range m.removedhashes {
			ids = append(ids, id)
		}
		return ids
	case sourcedata.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case sourcedata.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhashes {
		edges = append(edges, sourcedata.EdgeHashes)
	}
	if m.cleareddocuments {
		edges = append(edges, sourcedata.EdgeDocuments)
	}
	if m.clearedmetadata {
		edges = append(edges, sourcedata.EdgeMetadata)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceDataMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcedata.EdgeHashes:
		return m.clearedhashes
	case sourcedata.EdgeDocuments:
		return m.cleareddocuments
	case sourcedata.EdgeMetadata:
		return m.clearedmetadata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceDataMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceDataMutation) ResetEdge(name string) error {
	switch name {
	case sourcedata.EdgeHashes:
		m.ResetHashes()
		return nil
	case sourcedata.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case sourcedata.EdgeMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown SourceData edge %s", name)
}

// ToolMutation represents an operation that mutates the Tool nodes in the graph.
type ToolMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	proto_message    **sbom.Tool
	name             *string
	version          *string
	vendor           *string
	clearedFields    map[string]struct{}
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	metadata         map[uuid.UUID]struct{}
	removedmetadata  map[uuid.UUID]struct{}
	clearedmetadata  bool
	done             bool
	oldValue         func(context.Context) (*Tool, error)
	predicates       []predicate.Tool
}

var _ ent.Mutation = (*ToolMutation)(nil)

// toolOption allows management of the mutation configuration using functional options.
type toolOption func(*ToolMutation)

// newToolMutation creates new mutation for the Tool entity.
func newToolMutation(c config, op Op, opts ...toolOption) *ToolMutation {
	m := &ToolMutation{
		config:        c,
		op:            op,
		typ:           TypeTool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolID sets the ID field of the mutation.
func withToolID(id uuid.UUID) toolOption {
	return func(m *ToolMutation) {
		var (
			err   error
			once  sync.Once
			value *Tool
		)
		m.oldValue = func(ctx context.Context) (*Tool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTool sets the old Tool of the mutation.
func withTool(node *Tool) toolOption {
	return func(m *ToolMutation) {
		m.oldValue = func(context.Context) (*Tool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tool entities.
func (m *ToolMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtoMessage sets the "proto_message" field.
func (m *ToolMutation) SetProtoMessage(s *sbom.Tool) {
	m.proto_message = &s
}

// ProtoMessage returns the value of the "proto_message" field in the mutation.
func (m *ToolMutation) ProtoMessage() (r *sbom.Tool, exists bool) {
	v := m.proto_message
	if v == nil {
		return
	}
	return *v, true
}

// OldProtoMessage returns the old "proto_message" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldProtoMessage(ctx context.Context) (v *sbom.Tool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtoMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtoMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtoMessage: %w", err)
	}
	return oldValue.ProtoMessage, nil
}

// ResetProtoMessage resets all changes to the "proto_message" field.
func (m *ToolMutation) ResetProtoMessage() {
	m.proto_message = nil
}

// SetName sets the "name" field.
func (m *ToolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ToolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ToolMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *ToolMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ToolMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ToolMutation) ResetVersion() {
	m.version = nil
}

// SetVendor sets the "vendor" field.
func (m *ToolMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ToolMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ToolMutation) ResetVendor() {
	m.vendor = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *ToolMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *ToolMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *ToolMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *ToolMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *ToolMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *ToolMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *ToolMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *ToolMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *ToolMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *ToolMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *ToolMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *ToolMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *ToolMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *ToolMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// Where appends a list predicates to the ToolMutation builder.
func (m *ToolMutation) Where(ps ...predicate.Tool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tool).
func (m *ToolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.proto_message != nil {
		fields = append(fields, tool.FieldProtoMessage)
	}
	if m.name != nil {
		fields = append(fields, tool.FieldName)
	}
	if m.version != nil {
		fields = append(fields, tool.FieldVersion)
	}
	if m.vendor != nil {
		fields = append(fields, tool.FieldVendor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tool.FieldProtoMessage:
		return m.ProtoMessage()
	case tool.FieldName:
		return m.Name()
	case tool.FieldVersion:
		return m.Version()
	case tool.FieldVendor:
		return m.Vendor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tool.FieldProtoMessage:
		return m.OldProtoMessage(ctx)
	case tool.FieldName:
		return m.OldName(ctx)
	case tool.FieldVersion:
		return m.OldVersion(ctx)
	case tool.FieldVendor:
		return m.OldVendor(ctx)
	}
	return nil, fmt.Errorf("unknown Tool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tool.FieldProtoMessage:
		v, ok := value.(*sbom.Tool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtoMessage(v)
		return nil
	case tool.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tool.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case tool.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolMutation) ResetField(name string) error {
	switch name {
	case tool.FieldProtoMessage:
		m.ResetProtoMessage()
		return nil
	case tool.FieldName:
		m.ResetName()
		return nil
	case tool.FieldVersion:
		m.ResetVersion()
		return nil
	case tool.FieldVendor:
		m.ResetVendor()
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.documents != nil {
		edges = append(edges, tool.EdgeDocuments)
	}
	if m.metadata != nil {
		edges = append(edges, tool.EdgeMetadata)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case tool.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddocuments != nil {
		edges = append(edges, tool.EdgeDocuments)
	}
	if m.removedmetadata != nil {
		edges = append(edges, tool.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case tool.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddocuments {
		edges = append(edges, tool.EdgeDocuments)
	}
	if m.clearedmetadata {
		edges = append(edges, tool.EdgeMetadata)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolMutation) EdgeCleared(name string) bool {
	switch name {
	case tool.EdgeDocuments:
		return m.cleareddocuments
	case tool.EdgeMetadata:
		return m.clearedmetadata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolMutation) ResetEdge(name string) error {
	switch name {
	case tool.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case tool.EdgeMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Tool edge %s", name)
}
